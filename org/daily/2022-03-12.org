:PROPERTIES:
:ID:       1627A8AC-7783-4D17-B019-9B98DE5E5709
:END:
#+title: 2022-03-12
#+HUGO_SECTION:daily
#+filetags: :draft:
#+filetags: :draft:
* 我的编程101tutorial
** 算法和数据结构
算法是「解决问题方法的形式化表达」,在[形式化表达]中隐含了什么,对于一个简单的算法,比如说swap
#+begin_src python
  #swap
  a = 1
  b = 2
  c = 0
  
  c = a
  a = b
  b = c
  return "a=" ,a ,"," ,"b=" ,b
  #-> a = 2, b = 1
#+end_src

#+RESULTS:
| a= | 2 | , | b= | 1 |

在这个算法中,形式化表达隐含了一个前提,就是数据将会能够放在桌子上,分别对应a,b,c这三个位置.这种位置的关系就是一种数据结构,在这里,就是a对应1,b对应2,这样的「名字-值」对的结构.
于是,算法和数据结构的关系就很明了了:算法是依照数据结构而成为算法的,如果一个算法没有一个清晰具体确定的数据结构对应数据存储的格式,这个算法就用不了,就「在算法间失格」了.

但是一个数据结构想要有用,也不能没有相应的算法.

而在时间的顺序上,可以是先有数据结构,比如一组从传感器来的数据,我们想办法分析它,就是把算法应用到这个数据上,形式化自然也依托在数据传过来时候的数据结构上;也可以是有了一个算法的思想,之后把数据重新组成算法要求的模样,比如算对数的时候,用二进制的d1d2d3等等来存储,或者在做SVD的时候,因为SVD用的是向量,而我手上这个数据是矩阵,就给它reshape成向量,来用.
** 有哪些数据结构呢?
只要是把数据存放的位置有了意义,我认为就可以称之为一种数据结构.像十进制的系统,111中的三个1,因为放置位置不同而代表不同大小的数值,就是一种数据结构.

而我们所谓「常见的数据结构」是具有一些在许多种数据结构中都能看见的形式.像是sequence,比如排队的时候,算数列的时候,记录与时间前后有关的信息的时候,都是当作是一个序列来记;或是collection,比如往袋子里装东西的时候,记录一个班里的人名,只要把东西都给记住就行了,没有三六九等的
*** 栈
栈,英文叫stack,模拟一个在一沓纸上面放纸拿纸的动作,放纸叫压(push),拿纸叫弹(pop).形式化地说,这是一种数据结构,遵循FILO原则,先进后出,后进先出,也就是你能拿到的元素,只有你最近放的一个.这个在结构上做出来的时间上临近的效果,就很好用来给两个程序部分沟通.比如说汇编语言里
#+begin_src asm
     push eax
     jmp L1
L1:  pop eax
    
     
#+end_src
,调用一个procedure只能自己跳过去,不好带参数的,参数就压到大家都在用的一个栈里面,整个程序里就只用这一个栈,什么都往里压,压完弹出来就OK,一点影响没有.调用函数了,往里压;循环嵌套了,往里压.到时候一个事情干完了,东西都弹出来了,因为是这个时间上临近的效果,就有一个局部的隔离,并且这个隔离是可以交错,只要保证对应就好.像括号的对称,和context的嵌套.
*** 线性表
我们看一个收集班级信息的表格,
| Student ID No. | Name      | Gender | Tele. |
|----------------+-----------+--------+-------|
|          10001 | John      | Male   |  1402 |
|          10002 | Carman    | Female |  8920 |
|          10003 | Lancaster | Male   |  8899 |
|                |           |        |       |
这个表格表现出一个什么,我们知道John和Carman是没关系的,轮到自己填的时候,就知道往下面一个填.像这样往下一个填的,我觉得就可以叫线性表.它就是突出一个前后挨着的关系,就像我们在本子里写一句话,每个字前面挨着一个,后面挨着一个,如此一个一个往下写的,一句话就可以存成一个线性表,当然它也可以存成一个语法分析树,同一组数据有不一样的存法.
像这样
| Adress/index | Data/a[index] |
|            0 | “d”           |
|            1 | ”f“           |
|            2 | 24            |
|            3 | :monster      |
|            4 | '+            |
就是一个一维数组,因为它只有一条.那么维度就是1了.他不像一个向量存在数组里,[1 2 3],看它有3个数,所以是三维向量.这里说维度,坐标写在数组下标里,a[1][2][3]才是一个三维数组,好像把数据存在一个魔方的每一个小方块里,而一个二维的数组就好像存在上面那个收集班级信息的表格.
*** 队列
队列queue和栈反一反,是一种数据结构遵循FIFO原则,先进的先出.它总体上模拟一个排队的模型,一般默认先到先得,先来的可以先排到,根据
*** 树
*** map
*** 其他的呢?
堆?哈希?集合?这些我暂时都不会涉及,因为这些我也不会.
没错!你现在看到的是一个beginner to beginner tutorial!你还会在我的频道和博客里看到我讲各种我的发现、理解和教一些做法,其中的绝大部分大概都会是这样的B2B模式.优点是初学者的各种问题和心情我都还记得,缺点是我知道的并不比你们多多少,可能有些太远的decision-result关联,我也没有发现,就没办法也分享给你们.当然,就像这个系列的其他作品一样,我也可以学完之后再来讲,但是我觉得我自己读tutorial的时候不喜欢有太多不那么重要的东西在里面,所以就没有加进去.当然,这也可能是上面讲的一个我没发现的关联,所以我要说「这份tutorial是free of any warranty的.」

