+++
title = "2022-03-21"
author = ["System Administrator"]
tags = ["draft", "draft"]
draft = true
+++

## project Euler #12 {#project-euler-12}

I bruteforce the devisors by testing all number under root of the INPUT,
A wiser approach is

```rust
apply
fn main() {
    let max = 500;
    let mut n = 1;
    loop {
	if find_num_factors(make_triangle_num(n)) >= max {
	    break
	}
	n += 1;
    }
    println!("{}", make_triangle_num(n));
}

fn make_triangle_num(n:i64) -> i64 {
    (n * (n + 1))/2
}

fn find_num_factors(mut n:i64) -> i64 {
    let mut r = 1;
    let mut z = 2;
    while n > 1 {
	let mut c = 0;
	loop {
	    if is_prime(z) && n%z == 0{
		c += 1;
		n /= z;
	    } else {
		r *= c + 1;
		z += 1;
		break
	    }
	}
    }
    r
}

fn is_prime(n:i64) -> bool {
    let mut ret = true;
    if n > 2 {
	for i in 2..((n as f64).sqrt() as i64)+1 {
	    if n%i == 0 {
		ret = false;
		break
	    }
	}
    } else if n == 0 || n == 1 {
	ret = false;
    }
    ret
}
```


## Project Euler #13 {#project-euler-13}

Large sum


## play blender! {#play-blender}


## Learning {#learning}

I have some learning preference


### 结构 {#结构}

-   The simplest -&gt; complexer machine
    我喜欢从一个系统作为最简单的系统,只有一两个元素,但也是一个完整可工作的系统时开始
-   Time evolution
    我喜欢一个理论的历史,最开始的时候是作为一个什么样的原始的理论被提出,看到什么想到的;之后是怎样加加删删各种修改到现在的样子.
    现在的样子必然不是真实,也不是独立的抽象,而是历史过程的总和.它成为现在这个样子并不是因为这是事实,而是因为历史上的某个实践或者趋势
-   dependency
    我喜欢一个复杂系统是怎样分成几个部分,一个对接一个联系最后实现目的的.它最好和上面的两个相匹配,让我可以知道这个系统最简单可以怎样,而所有的部件都是什么时候,因为什么装上去,变成了现在这个样子.


### 记住,使用,熟悉机器 {#记住-使用-熟悉机器}

-   Concrete, Reasoned
    我喜欢确定的事实和定义.我需要知道它为什么make sense,我为什么这样做,而不是什么都不做.
    这个说法最有趣,最重要的「不同观点」是什么.
-   Managable, Flexible, Hand

s-onad