+++
title = "2022-03-05"
author = ["System Administrator"]
tags = ["draft", "draft"]
draft = true
+++

## A good code of list comprehension in python {#a-good-code-of-list-comprehension-in-python}

[clojure]({{< relref "../main/20220105010107-clojure.md" >}})'s `for` list comprehension function have similar use. now this use of for in python seems very flexible.

```python
  #grid is a 20 * 20 matrix

  print max([reduce(operator.mul, [grid[y+n*d[0]][x+n*d[1]] for n in (0,1,2,3)])
	  for x in xrange(0,20) for y in xrange(3,23)
	  for d in ((0,1),(1,0),(1,1),(-1,1))])

 # another really nice one with list comprehension
  #I guess mine would be brute force too. I just calculate the 4-tuple products of all rows, all columns, all right diagonals and all the left diagonals. The cool part was using list comprehensions to figure out everything. Python rocks ! I see other people had much better ways using Python but this was still fun :)

from time import *
import string

lines = [x[:-1] for x in open('11.txt','r').readlines()]
rows = [map(int, string.split(x)) for x in lines]
rowproducts = []
for row in rows:
    rowproducts.extend([y[0]*y[1]*y[2]*y[3] for y in [row[i:i+4] for i in range(17)]])

cols = [[rows[i][j] for i in range(20)] for j in range(20)]
colproducts = []
for col in cols:
    colproducts.extend([y[0]*y[1]*y[2]*y[3] for y in [col[i:i+4] for i in range(17)]])

r_upper_rows = [[rows[i][j] for j in range(i,20)] for i in range(20)]
upper_rdiags = [[x[i] for x in r_upper_rows[:-i]] for i in range(1,20)]
r_lower_cols = [[cols[i][j] for j in range(i,20)] for i in range(20)]
lower_rdiags = [[x[i] for x in r_lower_cols[:-i]] for i in range(1,20)]
rdiags_all = upper_rdiags + lower_rdiags + [[rows[i][i] for  i in range(20)]]

rdiags = [x for x in rdiags_all if len(x) >= 4]
rdiagproducts = []
for rdiag in rdiags:
    rdiagproducts.extend([y[0]*y[1]*y[2]*y[3] for y in [rdiag[i:i+4] for i in range(len(rdiag)-3)]])

l_upper_rows = [[rows[i][j] for j in range(19-i,-1,-1)] for i in range(20)]
upper_ldiags = [[x[i] for x in l_upper_rows[:-i]] for i in range(1,20)]
l_lower_cols = [[cols[i][j] for j in range(19-i,20)] for i in range(19,-1,-1)]
lower_ldiags = [[x[i] for x in l_lower_cols[:-i]] for i in range(1,20)]
ldiags_all = upper_ldiags + lower_ldiags + [[rows[i][19-i] for i in range(20)]]

ldiags = [x for x in ldiags_all if len(x) >= 4]
ldiagproducts = []
for ldiag in ldiags:
    ldiagproducts.extend([y[0]*y[1]*y[2]*y[3] for y in [ldiag[i:i+4] for i in range(len(ldiag)-3)]])

print max([max(rowproducts), max(colproducts), max(rdiagproducts), max(ldiagproducts)])
```