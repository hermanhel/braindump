<!DOCTYPE html>
<html><title>search</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />


<link rel="stylesheet" href="https://hermanhel.github.io/braindump/css/main.min.291920189b1189fd3388c38fd9e8ccbdf24640f05f020c32e3da5ba83f9bd5d8.css"/>
<body><header>
    <a href="/" id="logo">
    <svg id="Capa_1" enable-background="new 0 0 511.992 511.992" height="512" viewBox="0 0 511.992 511.992" width="512" xmlns="http://www.w3.org/2000/svg"><g><g><g><path d="m256 420.826c0 38.345-11.844 68.545-49.991 68.014-27.744-.385-51.481-15.31-61.853-39.46-1.239-2.887-4.024-4.734-7.154-4.725-.07 0-.135 0-.201 0-47.474 0-75.537-26.171-75.537-73.882 0-5.633.542-11.138 1.568-16.468.62-3.229-.825-6.489-3.671-8.125-35.493-20.432-49.161-46.127-49.161-90.183 0-44.057 13.668-69.757 49.161-90.185 2.846-1.636 4.291-4.896 3.671-8.13-1.026-5.33-1.568-10.83-1.568-16.463 0-47.711 28.064-73.882 75.537-73.882h.201c3.13.009 5.915-1.837 7.154-4.729 10.372-24.145 34.109-39.069 61.853-39.455 38.15-.532 49.991 29.668 49.991 68.013" fill="#ff9eb1"/></g><g><g><g><path d="m256 91.166c0-38.344 11.844-68.545 49.991-68.014 27.744.385 51.481 15.31 61.853 39.46 1.239 2.887 4.024 4.734 7.154 4.724h.201c47.474 0 75.537 26.171 75.537 73.882 0 5.633-.542 11.138-1.568 16.468-.62 3.229.825 6.489 3.671 8.125 35.493 20.434 49.161 46.128 49.161 90.185s-13.668 69.756-49.161 90.185c-2.846 1.636-4.291 4.896-3.671 8.13 1.026 5.33 1.568 10.83 1.568 16.463 0 47.711-28.064 73.882-75.537 73.882h-.201c-3.13-.009-5.915 1.837-7.154 4.729-10.372 24.145-34.109 39.069-61.853 39.455-38.15.531-49.991-29.669-49.991-68.014" fill="#ff7d97"/></g></g><g><g><path d="m502 265.996c-4.193 0-7.984-2.713-9.407-6.636-1.419-3.912-.16-8.459 3.063-11.092 3.291-2.689 8.009-2.99 11.621-.758 3.568 2.205 5.404 6.578 4.478 10.669-1.02 4.501-5.126 7.817-9.755 7.817z"/></g></g></g><g><path d="m340.83 229.18h-58.013v-58.014h-53.634v58.014h-58.013v53.633h58.013v58.013h53.634v-58.013h58.013z" fill="#faf7f5"/></g></g><g><g><path d="m498.468 291.859c-5.141-2.02-10.945.508-12.965 5.648-6.442 16.389-18.055 28.727-37.649 40.005-6.513 3.746-9.932 11.253-8.505 18.689.921 4.783 1.388 9.686 1.388 14.572 0 41.792-22.662 63.882-65.537 63.882h-.225c-.938 0-1.864.074-2.771.217-15.031-4.92-23.796-20.93-19.661-36.479 1.42-5.337-1.757-10.815-7.094-12.234-5.333-1.418-10.814 1.756-12.234 7.094-5.958 22.405 4.241 45.396 23.384 56.443-9.583 17.791-28.602 28.836-50.748 29.145-11.303.146-19.802-2.743-26.011-8.867-9.184-9.057-13.84-25.592-13.84-49.148v-70h16.816c5.522 0 10-4.477 10-10v-48.014h48.014c5.522 0 10-4.477 10-10v-53.632c0-5.523-4.478-10-10-10h-48.014v-48.014c0-5.523-4.478-10-10-10h-16.816v-70c0-23.555 4.657-40.09 13.841-49.148 6.21-6.123 14.696-9.022 26.011-8.867 23.862.332 44.096 13.132 52.803 33.405.218.509.458 1.003.719 1.483-3.225 8.243-9.084 15.093-16.833 19.574-8.993 5.2-19.465 6.581-29.485 3.89-5.337-1.434-10.819 1.73-12.251 7.064-1.433 5.334 1.729 10.819 7.063 12.252 5.074 1.363 10.221 2.037 15.338 2.037 10.2 0 20.272-2.681 29.346-7.928 11.083-6.408 19.607-16.017 24.616-27.575 41.6.67 63.569 22.718 63.569 63.866 0 4.89-.467 9.794-1.389 14.582-1.427 7.426 1.991 14.933 8.502 18.678 19.572 11.267 31.176 23.584 37.625 39.936 1.552 3.934 5.318 6.334 9.306 6.333 1.221 0 2.462-.225 3.666-.7 5.138-2.026 7.66-7.834 5.634-12.972-7.943-20.141-22.201-35.773-44.801-49.086.967-5.521 1.457-11.155 1.457-16.772 0-52.114-31.48-83.391-84.288-83.876-12.157-26.863-38.963-43.753-70.318-44.189-16.67-.232-30.255 4.688-40.332 14.625-3.813 3.76-7.08 8.226-9.797 13.382-2.717-5.156-5.984-9.622-9.797-13.382-10.075-9.937-23.668-14.852-40.333-14.625-31.353.437-58.158 17.325-70.32 44.189-52.807.485-84.286 31.762-84.286 83.876 0 5.617.49 11.253 1.458 16.771-37.422 22.031-52.724 50.552-52.724 98.008 0 47.451 15.299 75.969 52.721 98.006-.967 5.521-1.457 11.154-1.457 16.772 0 52.114 31.48 83.391 84.288 83.876 12.157 26.863 38.963 43.753 70.318 44.189.377.005.751.008 1.125.008 16.172 0 29.358-4.92 39.207-14.632 3.813-3.76 7.08-8.226 9.797-13.382 2.717 5.156 5.984 9.622 9.797 13.382 9.849 9.713 23.034 14.633 39.208 14.632.373 0 .749-.003 1.125-.008 31.352-.436 58.158-17.325 70.32-44.189 52.807-.485 84.286-31.762 84.286-83.876 0-5.617-.49-11.253-1.458-16.772 22.634-13.329 36.901-28.989 44.838-49.178 2.022-5.14-.507-10.945-5.647-12.966zm-215.652-52.679h48.014v33.633h-48.014c-5.522 0-10 4.477-10 10v48.014h-33.633v-48.014c0-5.523-4.477-10-10-10h-48.013v-33.633h48.014c5.523 0 10-4.477 10-10v-48.014h33.633v48.014c-.001 5.523 4.477 10 9.999 10zm-50.657 230.794c-6.21 6.124-14.717 9.018-26.011 8.867-23.862-.331-44.096-13.132-52.803-33.405-.218-.509-.458-1.003-.719-1.483 3.225-8.243 9.085-15.093 16.833-19.574 8.992-5.2 19.463-6.581 29.485-3.89 5.337 1.434 10.819-1.73 12.251-7.064 1.433-5.333-1.73-10.819-7.064-12.251-15.188-4.08-31.059-1.988-44.684 5.891-11.083 6.408-19.607 16.017-24.616 27.575-41.6-.67-63.569-22.718-63.569-63.866 0-4.89.467-9.794 1.389-14.582 1.427-7.427-1.991-14.934-8.502-18.678-32.183-18.528-44.149-40.621-44.149-81.517 0-40.9 11.966-62.994 44.146-81.517 6.513-3.746 9.932-11.253 8.505-18.689-.921-4.783-1.388-9.686-1.388-14.572 0-41.792 22.662-63.882 65.537-63.882h.225c.938 0 1.864-.074 2.771-.217 15.031 4.92 23.796 20.93 19.661 36.479-1.42 5.337 1.757 10.815 7.094 12.234.861.229 1.726.338 2.577.338 4.422 0 8.467-2.956 9.657-7.432 5.958-22.405-4.241-45.396-23.384-56.443 9.583-17.791 28.602-28.836 50.748-29.145 11.267-.15 19.801 2.743 26.011 8.867 9.184 9.057 13.84 25.592 13.84 49.148v70h-16.816c-5.522 0-10 4.477-10 10v48.014h-48.014c-5.522 0-10 4.477-10 10v53.633c0 5.523 4.478 10 10 10h48.014v48.014c0 5.523 4.478 10 10 10h16.816v70c0 23.554-4.657 40.09-13.841 49.147z"/><path d="m139.699 228.227c-6.766 0-13.186 1.514-18.907 4.31-3.049-8.65-8.286-16.485-15.336-22.673-4.151-3.643-10.469-3.233-14.113.918-3.643 4.15-3.232 10.469.918 14.112 6.711 5.891 10.816 14.143 11.498 22.953-1.213 1.914-2.293 3.946-3.225 6.088-1.145 2.633-2.015 5.316-2.615 8.019-13.414 11.422-33.601 10.834-46.225-1.792-3.906-3.904-10.236-3.904-14.143 0-3.905 3.905-3.905 10.237 0 14.143 10.524 10.524 24.354 15.784 38.193 15.784 8.04 0 16.083-1.775 23.484-5.325 1.904 5.443 4.967 10.557 9.136 15.03.596.639 1.204 1.269 1.826 1.891 1.953 1.953 4.512 2.929 7.071 2.929 2.56 0 5.118-.976 7.071-2.929 3.905-3.905 3.905-10.237 0-14.143-.458-.458-.906-.922-1.342-1.389-6.26-6.716-7.799-15.778-4.118-24.241 2.878-6.616 9.86-13.686 20.826-13.686 5.522 0 10-4.477 10-10 .001-5.522-4.476-9.999-9.999-9.999z"/><path d="m387.667 287.543c-3.905 3.905-3.905 10.237 0 14.143 1.953 1.953 4.512 2.929 7.071 2.929s5.118-.976 7.071-2.929c.622-.622 1.23-1.253 1.83-1.896 4.167-4.471 7.229-9.583 9.133-15.025 7.401 3.549 15.444 5.324 23.484 5.324 13.839 0 27.67-5.261 38.193-15.784 3.905-3.905 3.905-10.237 0-14.143-3.906-3.904-10.236-3.904-14.143 0-12.624 12.625-32.811 13.214-46.225 1.792-.6-2.702-1.47-5.386-2.615-8.019-.932-2.142-2.012-4.175-3.225-6.088.682-8.81 4.787-17.062 11.498-22.953 4.15-3.644 4.561-9.962.918-14.112-3.646-4.151-9.964-4.563-14.113-.918-7.05 6.189-12.287 14.023-15.336 22.673-5.721-2.796-12.141-4.31-18.907-4.31-5.523 0-10 4.477-10 10s4.477 10 10 10c10.966 0 17.948 7.07 20.826 13.686 3.681 8.463 2.142 17.525-4.114 24.237-.44.47-.888.935-1.346 1.393z"/></g></g></g></svg>
  </a>
  <h3 class="site-title">Herman&#39;s place</h3><form id="search"
    action='https://hermanhel.github.io/braindump/search/' method="get">
    <label hidden for="search-input">Search site</label>
    <input type="text" id="search-input" name="query"
    placeholder="Type here to search">
    <input type="submit" value="search">
</form>
</header>

<div class="grid-container">
    <div class="grid">
        <div class="page wide">
            <ul id="results">
                <li>
                    Enter a keyword above to search this site.
                </li>
            </ul>
        </div>
    </div>
</div><script>
window.store = {
    
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/daily\/2022-05-02\/": {
        
        "title": "2022-05-02*",
        "tags": ["draft","draft",],
        "content": "PROPERTIES: :ID: 4FBDA423-3258-4C4E-BBA1-408DCA2D036B\nrewrite hermhel/org-find-headline-in-buffer-olp in cond fashion. the conditions are:\n  not finding:\n if the buffer contains no heading then add 1 matching the first heading in path search again if not on a heading only when going in the buffer for the first time goto the next heading if the buffer have heading, but the top level have no headings of cur-finding add 1 heading at end, with cur-finding, search again if the level (not top level) have no heading of cur-finding insert a heading at end of level with cur-ding search again    finding:\n finding a match, but no subheading(this is the match) create a heading and search a again finding a match with subheadings(this is the match) go to next heading(the child level)    (defun hermanhel/org-find-headline-in-buffer-olp (path)  (interactive)  (goto-char (point-min))   (while (and (not (equal (length path) 0)))  (let ((cur-finding (car path)))  (cond  ;; if buffer have no heading  ((not (org-ml-this-buffer-has-headlines))  ;;insert cur-finding heading at end of buffer  (goto-char (point-max))  (org-insert-heading)  (insert cur-finding));;and search again(another round of while loop)  ;; if buffer have headings, and  ;; now not on a heading(at the beginning of program)  ((not(org-on-heading-p))  ;;goto next heading  (org-next-visible-heading 1))  ;; if the buffer have heading and now on a heading  ;; and at top level and this level have no headings same as cur-finding(last node and is not)  ((and (equal (nth 1 (org-heading-components)) 1) \t(equal (save-excursion \t(outline-end-of-subtree) \t(point)) \t(point-max)) \t(not (equal (nth 4 (org-heading-components)) cur-finding)))  ;; insert a heading at end  (org-insert-heading-respect-content)  (insert cur-finding))  ;; buffer have heading, now on a heading,  ;; and not on top, last node, and is not  ((and (\u0026gt; (nth 1 (org-heading-components)) 1) \t(equal (save-excursion \t(outline-end-of-subtree) \t(point)) \t(save-excursion \t(outline-up-heading 1) \t(outline-end-of-subtree) \t(point))) \t(not (equal (nth 4 (org-heading-components)) cur-finding)))  ;;insert at same level at end  (org-insert-heading-respect-content)  (insert cur-finding)   )  ;;buffer have heading, now on a heading,  ;;find a match, cur-finding is the last in path  ((and (equal (nth 4 (org-heading-components)) cur-finding) \t(equal (length path) 1)   )  (setq path (cdr path)))   ;; buffer have heading, now on a heading,  ;; and find a match, and have no subheadings  ((and (equal (nth 4 (org-heading-components)) cur-finding) \t(not (outline-has-subheading-p)))  ;; insert a subheading with next heading in path  (end-of-line)  (org-insert-heading)  (org-do-demote)  (insert (nth 1 path))  ;; go back a level, to maintain the consistency of end state in this cond.  (setq path (cdr path)  ))  ;; buffer have heading, now on a heading,  ;; and find a match, and have subheadings  ((and (equal (nth 4 (org-heading-components)) cur-finding) \t(outline-has-subheading-p))  ;;goto next level, shrink path to search next heading  (org-next-visible-heading 1)  (setq path (cdr path))  )  ;; buffer have heading, now on a heading, in the middle, not finding it,  ;; not any above  (t  (org-forward-heading-same-level 1))  )))) ;;test (hermanhel/org-find-headline-in-buffer-olp \u0026#39;(\u0026#34;herman\u0026#34; \u0026#34;is\u0026#34; \u0026#34;so\u0026#34; \u0026#34;handsome\u0026#34;)) herman is so  handsome  ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/daily\/2022-05-02\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/tags\/algorithm\/": {
        
        "title": "algorithm",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/tags\/algorithm\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/binary_searching\/": {
        
        "title": "Binary-searching",
        "tags": ["algorithm",],
        "content": "Binary searching is a searching algorithm for sorted data.\nInput proposition  sorted  Algorithm Algorithm B (Binary-search) With given sorted seq S, find POS of value ELT in S. B1. [Middle value] Find middle value MID of S, compare MID and ELT B2. [Change field] If MID \u0026gt; ELT, then change search region to the lesser side of MID of S B3. [recur] Repeat from B1, until S have length 1, where if MID \\(\\neq\\) ELT, then there\u0026rsquo;s no ELT in S.\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/binary_searching\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/categories\/": {
        
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/categories\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/daily\/": {
        
        "title": "Dailies",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/daily\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/tags\/draft\/": {
        
        "title": "draft",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/tags\/draft\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/errors\/": {
        
        "title": "Errors",
        "tags": [],
        "content": "Whoops! It seems like you\u0026rsquo;ve clicked a Broken Link\u0026hellip;\u0026hellip;very\u0026hellip;naughty\u0026hellip;?\nBroken link They present in 3 conditions:\n a link to my local file on my local machines a link to a draft node that is either not created or published to this site or\u0026hellip;I made a mistake and typed it wrong. But what are the odds! like\u0026hellip;67%?  This Braindump is intended to be portable and concise. Yet I\u0026rsquo;m still facing a large amount of nonsence-rich notes, as illustrated by the few nodes on this braindump available. As my one-way mentor on this art Jethro said, a note to be reviewd should be self-containing and refined, especially when it comes to Zettelkasten Notes. Yet I disagree his rejection of broken window in Zettels, for my favourite thing is to mess around the field without worrying breaking expansive vases. Yet I agree that a place hold for a consice conclusion looks quite nice, so this place as a subset of all my messing around is narrowed to try to give a clear image.\nAmong all the things you\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/errors\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/": {
        
        "title": "Good Morning!",
        "tags": [],
        "content": "GOOD MORNING! \u0026hellip;and in case it\u0026rsquo;s not morning, good afternoon and good night!\nIt seems\u0026hellip;you have stumbled into Herman\u0026rsquo;s forbidden braindump! Enjoy your time here!\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/inbox\/": {
        
        "title": "Inbox",
        "tags": [],
        "content": "蘇格拉底詰問程序 將蘇格拉底詰問法寫成formulated的算法,然後像doctor一樣實施,讓大家可以自己嘗試被詰問.\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/inbox\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/20220423190558-linear_algebra\/": {
        
        "title": "Linear Algebra",
        "tags": [],
        "content": "Linear Algebra is set of algebra formulated rules, formulated methods and found facts\nResource  This note is originally a reading note on math4ml. I\u0026rsquo;m adding my own insights afterwards.  Spaces Vector space set of vectors defining:\n add operation: v1 + v2 scale operation: n * v1  propositions  0: x + 0 = x -x: for each x, exist -x + x = 0 1: 1x = x commutativity: x+y=y+x Associativity: (x+y)+z=x+(y+z),(ab)x=a(bx) Distributivity: a(x + y) = ax + ay  linear combination  set of vectors: \\(V=\\{v_1,v_2\u0026hellip;\\}\\) set of real numbers: \\(R = \\{a_1,a_2\u0026hellip;\\}\\) linear combination: \\(a_1v_1 + a_2v_2+\u0026hellip;+a_nv_n\\)  linear independent only combination of \\(a_1v_1+a_2v_2+a_3v_3+\u0026hellip;=0\\) is \\(a_1 = a_2 = \u0026hellip; = 0\\)\nspan \\(span(V)\\) is set that: for every \\(v \\in span(V)\\), \\(v\\) can be written as a linear combination of \\(V\\).\nbasis basis is a set of vector \\(V\\) such that:\n \\(V\\) is linear independent with respect to \\(span(V)\\)  for every set of linear independent vectors, they are a basis for its span.\nfinite-dimensional confusing vector space \\(V\\) that is spanned by a finite number of vectors.\n Infinite-dimensional vector space: spanned by infinite number of vectors dimension: \\(dim(V)\\) of \\(span(V)\\) is the number of vectors in \\(V\\)  Euclidean space \\(\\mathbb{R}^n\\). Vector space spanned by a n-tuple linear independent basis.\n used to represent physical space.  subspace \\(S\\) is part of \\(V\\)\n  propositions\n 0: \\(0 \\in S\\) +: \\(S\\) is closed under addition *: \\(S\\) is closed under scale. self: \\(V\\) is a subspace of \\(V\\), 0 is a subspace of 0 space+space: \\(U \\in V + W \\in V = S \\in V\\) dim of space+space: \\(dim(U + W) = dim(U)+dim(W)-dim(U \\cap W)\\)      direct sum\n\\(U \\oplus W\\) when \\(U \\cup W =\\{0\\}\\).\n  propositions\n unique linear combination: each \\(v\\) in \\(U \\oplus W\\) can be uniquely written as \\(u + w\\) \\(dim(U + W) = dim(U)+dim(W)\\)      Metric space Normed Space Inner product space Linear Map a function \\(T:V \\rightarrow W\\)\nsatisfies:  T(x+y)=T(x)+T(y) T(ax)=aT(x)  identical sturcutr to Vector space\nLinear Operator a Linear Map from \\(V\\) to \\(V\\)\nhomomorphism confusing a map is a homomorphism if:\n input and output is the same type(both are Vector Space) the structure is preserved  is a 3d to 2d map homomorphism? ismorphism invertible homomorphism\n \\(V\\) and \\(W\\) are ismorphic when \\(\\exists\\) homomorphism between \\(V\\) and \\(W\\): \\(V \\cong W\\) ismorphic vecter spaces are the same in algebraic structure (both [x1,x2,x3,x4])    proposition\n dimension: finite-dimensional vector space of the same dimension are ismorphic to Eucliead: any n-dimensional vector space is ismorphic to \\(\\mathbb{R}^n\\)   proof: at least exist a map that map n bases of \\(V\\) to n bases of \\(W\\).\n\\begin{aligned} \\varphi: V \u0026amp; \\rightarrow W \\\\ \\alpha_{1} \\mathbf{v}_{1}+\\cdots+\\alpha_{n} \\mathbf{v}_{n} \u0026amp; \\mapsto \\alpha_{1} \\mathbf{w}_{1}+\\cdots+\\alpha_{n} \\mathbf{w}_{n} \\end{aligned}\n       Matrix of Linear Map for \\(T:V \\rightarrow W\\) where \\(V\\) have basis \\(v_1,v_2,\u0026hellip;,v_n\\), \\(W\\) have basis \\(w_1,w_2,\u0026hellip;,w_m\\).\nformulated notation for \\(Tx = Ax = v\\), \\(A\\) is matrix representing Linear Map T\n A consist of:  columns: base vectors in column space \\(V\\).   x is vector in row space \\(V\\), that will be mapped into \\(W\\) by \\(A\\).  Transpose flip the matrix by diagnoal, row-\u0026gt;column, column-\u0026gt;row\n  operations\n double: \\((A^T)^T = A\\) \\((A+B)^T=A^T+B^T\\) \\((aA)^T=aA^T\\) \\((AB)^T=B^TA^T\\)    TODOColumn space and row space difference between left product and right product, how do they(column space and row space) connect.\ndomain \\(V\\)\ncodomain \\(W\\)\nNullspace \\(null(T)=\\{v \\in V | Tv=0\\}\\)\n the space being mapped into 0 subspace of V(domain)  Range \\(range(T)=\\{w\\in W|\\exists v \\in V\\) such that \\(Tv=w\\}\\)\n parts of \\(W\\) that is filled by \\(TV\\) subspace of W(codomain)  columnspace span of \\(A\\)\u0026rsquo;s columns.\n exactly the range of \\(A\\). so denoted by \\(range(A)\\)   TODOFormulated proof of columnspace=range(A)  rowspace span of \\(A\\)\u0026rsquo;s rows.\n exactly the range of \\(A^T\\). so denoted by \\(range(A^T\\))  rank the dimension of columnspace and rowspace is the same. And that\u0026rsquo;s the rank of \\(A\\).\nMetric Space a set with a difined metric is a metric space\ngeneralization of distant from Euclidean space\nmetric distant function.\na metric \\(d\\) on set \\(S\\) is a function \\(d: S \\times S \\rightarrow \\mathbb{R}\\) the \\(S \\times S\\) means \\(d\\) take 2 args from set \\(S\\)\nmotivation: to define limit to enable calculus.\n  propositions\n \\(d(x,y) \\ge 0\\) \\(d(x,y)=d(y,x)\\) \\(d(x,z) \\ge d(x,y)+d(y,z)\\)      example in sequence\nconverge: d(x_n,x)\u0026lt;e, where d(x_n,x) is defined as d(x,y)=|x - y|\n  Normed space a Vector space with norm defined.\ngeneralization of length from Euclidean space\nnorm a function ∥·∥:V →R.\n  propositions\n \\(||x|| \\ge 0\\) \\(||ax|| = |a|||x||\\) \\(||x+y|| \\le ||x||+||y||\\) a Normed space is a Metric space in finite-dimensional space, all norms converge the same time.  proof:        important norms\n\\begin{aligned} \\|\\mathbf{x}\\|_{1} \u0026amp;=\\sum_{i=1}^{n}\\left|x_{i}\\right| \\\\ \\|\\mathbf{x}\\|_{2} \u0026amp;=\\sqrt{\\sum_{i=1}^{n} x_{i}^{2}} \\\\ \\|\\mathbf{x}\\|_{p} \u0026amp;=\\left(\\sum_{i=1}^{n}\\left|x_{i}\\right|^{p}\\right)^{\\frac{1}{p}} \\quad(p \\geq 1) \\\\ \\|\\mathbf{x}\\|_{\\infty} \u0026amp;=\\max _{1 \\leq i \\leq n}\\left|x_{i}\\right| \\end{aligned}\n1: sum of cordinates 2: Pythagorean distance\n  Inner product space a real Vector space that defines inner product\ninner product function \\(\\langle\\cdot, \\cdot\\rangle: V \\times V \\rightarrow \\mathbb{R}\\)\n  propositions\n greater than 0 linear in the first slot.  why?   no direction inner produt induce a norm \\(||x||=\\sqrt{\\langle x,x \\rangle}\\), so an Inner product space is also a Normed space      standard inner product on \\(\\mathbb{R}^{n}\\)\n\\(\\langle\\mathbf{x}, \\mathbf{y}\\rangle=\\sum_{i=1}^{n} x_{i} y_{i}=\\mathbf{x}^{\\top} \\mathbf{y}\\)\n  orthogonal vectors x and y are orthogonal if \\(\\langle\\cdot, \\cdot\\rangle = 0\\)\n  orthonormal\nvectors x and y are orthonormal if:\n \\(\\langle x, y \\rangle = 0\\) \\(||x||=||y||=1\\)     Pythagorean Theorem    Cauchy-Schwarz inequality\ncomes in handy sometimes in proving bounds \\(| \\langle x,y \\rangle| \\le ||x|| ||y||\\)\n Equal when:  x = ay when they are linear independent        orthogonal complement\nfor \\(S \\sube V\\) where \\(V\\) is an Inner product space: \\(S^{\\perp}\\), the orthogonal complement of S, is \\(S^{\\perp}=\\{\\mathbf{v} \\in V \\mid \\mathbf{v} \\perp \\mathbf{s}\\) for all \\(\\mathbf{s} \\in S\\}\\) i.e. all other vectors in V that is orthogonal to all vectors in S\n  propositions\n  when S is a finite dimensional subspace of V\n \\(v = v_S+v_{\\perp}\\) for every \\(v \\in V\\)  when V is a inner product space     TODOproof   TODOproof of uniqueness      orthogonal projection\n\\begin{aligned} PS: \u0026amp; V → S \\\\ \\mathbf{v} \u0026amp; \\mapsto \\mathbf{v}S\\end{aligned}The mapping from V to S. Project to the (plane) space S\n  propoties\n content: \\(P_Sv=\\langle v,u_1 \\rangle u_1 + \u0026hellip; + \\langle v,u_m \\rangle u_m\\) u_1 are orthonormal basis of S triangle \\(v-P_sv \\perp S\\) \\(P_S\\) is a linear map \\(P_Ss=s\\) \\(range(P_S)=S\\), \\(null(P_S)=S^{\\perp}\\) \\(P_S^2=P_S\\) \\(||P_Sv|| \\le ||v||\\) shortest path: \\(\\left\\|\\mathbf{v}-P_{S} \\mathbf{v}\\right\\| \\leq\\|\\mathbf{v}-\\mathbf{s}\\|\\) with equality if and only if \\(\\mathbf{s}=P_{S} \\mathbf{v}\\). That is, \\(P_{S} \\mathbf{v}=\\underset{\\mathbf{s} \\in S}{\\arg \\min }\\|\\mathbf{v}-\\mathbf{s}\\|\\) \\(P_S=\\sum^{m}_{i=1}u_iu_i^T=UU^T\\), where \\(U\\) have \\(u_1,\u0026hellip;,u_m\\) as it\u0026rsquo;s columns    TODOProof of the propoty 8\nx-devonthink-item://717C4CDF-09AB-41FA-95C1-BBB9155432C6?page=12\n        projection\nlinear map \\(P\\) that:\n \\(P^2 = P\\)       S don\u0026rsquo;t have to be a subspace of V? confusing   argmin? confusing    Eigenthings for any \\(Ax=\\lambda x\\), i.e. after Linear Map \\(x\\) only scaled on its direction:\n \\(\\lambda\\) is eigenvalue \\(x\\) is eigenvector 0 is excluded in vector, but not eigenvalue.  propositions: for \\(Ax=\\lambda x\\)  \\(x\\) is an eigenvector of \\(A+aI\\) with eigenvalue \\(\\lambda + a\\) if A is invertible, x is an eigenvector of \\(A^{-1}\\) with =eigenvalue \\(\\lambda^{-1}\\) \\(A^kx=\\lambda^kx\\)  TODOproof of 1,2,3 Trace Trace of a square matrix is the sum of its diagonal entries \\(tr(A)=\\sum_{i=1}^n A_{ii}\\)\nproperties  \\(tr(A+B)=tr(A)+tr(B)\\) \\(tr(\\alpha A)=\\alpha tr(b)\\) \\(tr(A^T)=tr(A)\\) \\(tr(ABCD)=tr(BCDA)=tr(CDAB)=tr(DABC)\\) trace of A equals to the sum of its eigenvalues  Determinant properties  det(I)= 1 \\((detA^T)=det(A)\\) det(A)det(B)=det(AB) \\((detA^{-1})=det(A)^{-1}\\) \\(det(\\alpha A)=\\alpha^n det(A)\\) determinant of A is the product of its eigenvalues  orthogonal matrix an orthogonal matrix have its colulmns orthonormal pairwise(every pair)\npropositions  \\(Q^TQ=QQ^T=I\\), \\(Q^T=Q^{-1}\\) inner product is reserved the same after both are mapped. (rotate/reflax) norm is reserved the same after both are mapped. (rotate/reflax)  symmetric matrix symmetric matrix \\(A=A^T\\)\npropositions Spectral Theorem a square matrix A is a symmetric matrix -\u0026gt; \\(\\exists\\) an orthonormal basis of A consisting of eigenvectors of A.\n  spectral decomposition(eigendecomposition)\n\\(A=QUQ^T\\)\n Q: matrix with columns eigenvectors U: matrix with diagnol eigenvalues corresponding    Rayleigh quotients for a symmetric matrix A \\(R_A(x)=\\frac{x^TAx}{x^Tx}\\)\n  propositions\n scale invariance: \\(R_A(\\alpha x)=R_A(x)\\) eigen: if x is a eigenvector of A with eigenvalue \\(\\lambda\\), then \\(R_A(x)=\\lambda\\) \\(\\lambda_{min}(A) \\le x^TAx \\le \\lambda_{max}(A)\\), equal when x is eigenvector \\(\\lambda_{min}(A) \\le R_A(x) \\le \\lambda_{max}(A)\\), equal when x is eigenvector   TODOprrof of 3,4      quadratic form\nfor a symmetric \\(A \\in \\mathbb{R}^{n \\times n}\\), \\(x^TAx\\) is a quadratic form\n  Positive semi-definite matrix a symmetric matrix A is positive semi-definite if:\n for all \\(x \\in \\mathbb{R}^n\\), \\(x^TAx \\ge 0\\)    positive definite matrix\na symmetric matrix A is positive semi-definite if:\n for all nonzero \\(x \\in \\mathbb{R}^n\\), \\(x^TAx \u0026gt; 0\\)  positive definite matrix is subset of positive semi-definite matrix\n    propositions\n a symmetric matrix is a Positive semi-definite matrix if and only if:  all its eigenvalues are nonnegative   a symmetric matrix is a Positive semi-definite matrix if and only if:  all its eigenvalues are positive   [arise] for \\(A \\in \\mathbb{R}^{m \\times n}\\), \\(A^TA\\) is a Positive semi-definite matrix. If \\(null(A) = \\{0\\}\\), then \\(A^TA\\) is a positive definite matrix in the proof, we round \\(A^TA\\) with \\(x^T(\u0026hellip;)x\\). Product of a matrix and its transpose. positive definite matrix is invertible (with nonzero eigenvalues). [making] for Positive semi-definite matrix A and positive \\(\\alpha\\), \\(A+\\alpha I\\) is positive definite matrix      geometry with positive definite quadratic form\nthe c-isocontour of function \\(f(x)=x^TAx\\) are ellopsoids such that:\n it\u0026rsquo;s axes point in the directions of eigenvectors of A it\u0026rsquo;s radii of these axes are proportional to the inverse quare roots of corresponding eigenvalues    level set\nlevel set or isocontour. \\(\\{x \\in dom f \\colon f(x)=c\\}\\) where a level line cut through the function contour.\n    singular value decomposition (SVD) every matrix \\(A \\in \\mathbb{R}^{m \\times n}\\) has a SVD: \\(A=U \\Sigma V^T\\), where:\n \\(U \\in \\mathbb{R}^{m \\times m}\\) is orthogonal matrix \\(V \\in \\mathbb{R}^{n \\times n}\\) is orthogonal matrix \\(\\Sigma \\in \\mathbb{R}^{m \\times n}\\) is a diagonal matrix with:  sigular values of A (\\(\\sigma_i\\)) on its diagonal the entries in non-increasing order(by convention)    anothre notation (with sum of outer product): \\(A=\\sum_{i=1}^{r}\\sigma_iu_iv_i^T\\), where:\n u_i is ith column of U v_i is ith column of V \\(\\sigma_i\\) is ith singular value  propositions  [valid entry] only first r = rank(A) singular values are nonzero.  eigendecomposition for \\(A^TA\\) and \\(AA^T\\) \\(A^TA = (U\\Sigma V^T)^TU\\Sigma V^T = V\\Sigma^TU^TU\\Sigma V^T=V\\Sigma^T\\Sigma V^T\\) \\(AA^T = U\\Sigma V^T(U\\Sigma V^T)^T =TU\\Sigma V^T V\\Sigma^TU^=U\\Sigma\\Sigma^T V^T\\) Therefore:\n columns of V are eigenvectors of \\(A^TA\\) columns of U are eigenvectors of \\(AA^T\\) singular values of A are square roost of eigenvalues of \\(A^TA\\)  Fundamental Theorem of Linear Algebra there are various versions. for \\(A \\in \\mathbb{R}^{m \\times n}\\):\n \\(null(A)= range(A^T)^{\\perp}\\) \\(null(A) \\oplus range(A^T)=\\mathbb{R}^n\\) \\(\\underbrace{\\operatorname{dim} \\operatorname{range}(\\mathbf{A})}_{\\operatorname{rank}(\\mathbf{A})}+\\operatorname{dim} \\operatorname{null}(\\mathbf{A})=n\\) for singular value decomposition \\(A=U\\SigmaV^T\\), columns of U and V form orthonormal bases for the four fundamental subspaces of A: r = rank(A)    subspace columns     range(A) first r columns of U   range(A^T) first r columns of V   null(A^T) last m-r columns of U   null(A) last n-r columns of V      operator norm for \\(T \\colon V \\rightarrow W\\), the operator norm of T is defined as: \\(\\|T\\|_{\\mathrm{op}}=\\max _{\\substack{\\mathbf{x} \\in V \\\\ \\mathbf{x} \\neq \\mathbf{0}}} \\frac{\\|T \\mathbf{x}\\|_{W}}{\\|\\mathbf{x}\\|_{V}}\\)\nfor \\(R^n \\rightarrow R^m\\) for matrix \\(A \\in \\mathbb{R}^{m \\times n}\\), when p-norm is used in both domain and codomain:\n matrix p-norm: \\(\\|\\mathbf{A}\\|_{p}=\\max _{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\|\\mathbf{A} \\mathbf{x}\\|_{p}}{\\|\\mathbf{x}\\|_{p}}\\) matrix 1-norm:\\(\\|\\mathbf{A}\\|_{1}=\\max _{1 \\leq j \\leq n} \\sum_{i=1}^{m}\\left|A_{i j}\\right|\\)(the largest column sum) matrix \\(\\infty - norm\\):\\(\\|\\mathbf{A}\\|_{\\infty}=\\max _{1 \\leq i \\leq m} \\sum_{j=1}^{n}\\left|A_{i j}\\right|\\)(the largest row sum) matrix 2-norm: \\(\\|A\\|_2 =\\sigma_1(A)\\)(the largest sigular value of A)  Propositions  \\(\\|Ax\\|_p \\le \\|A\\|_P\\|x\\|_p\\)(by definition) \\(\\|AB\\|_p \\le \\|A\\|_P\\|B\\|_p\\)(proof)  Frobenius norm \\(\\|\\mathbf{A}\\|_{\\mathrm{F}}=\\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} A_{i j}^{2}}=\\sqrt{\\operatorname{tr}\\left(\\mathbf{A}^{\\top} \\mathbf{A}\\right)}=\\sqrt{\\sum_{i=1}^{\\min (m, n)} \\sigma_{i}^{2}(\\mathbf{A})}\\)\ndimension dimension is the number of vectors in 1 orthonormal base of V\ninvertible ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/20220423190558-linear_algebra\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/tags\/machine\/": {
        
        "title": "machine",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/tags\/machine\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/20211104155334-machine\/": {
        
        "title": "Machine",
        "tags": [],
        "content": "Decription Machine typically should contain below information:\n Flow of action. In similar format as Algorithm Notation Other than actions, materials and places should be spcified here also, like in algorithms. Related Principles. Proof should be included in the principles\u0026rsquo; node. If the principle have no proof, note that [noProof] principle xxxx  Categories Purpose Project machines A machine could be constructed just for a particular project, with itself used for only once.\nSuch machine have components that should work with each other that will make the project success, like my credit in EAP121 or make a particular robot.\ncomponents could be preparation of a presentation or moving algorithm of the robot\nEveryday machines machines could also be designed to deal with a type of repetitive occuring tasks, like loundary.\nShape Chain with steps and components and levels one after another to reach a higher height\nLoop With repeating steps to accumulate and build height.\nMachine page machine page holdes all information of the machine, including implementation, scientific source, experiance reasons .etc.\nImplementation When applying the machine in task/sessions, there could be some measures as below:\nInformation Scheme There could be specific place to seek information needed for the machine.\nExample:\n slides-from lmo mail list-collect through university websites  Currently, the informations are perfered to be collected in the scheme session, and wrote as detailed plan in the task descriptions.\nInstead of that, a Information Scheme could be established in the task description, with structure specified in the Machine page .\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/20211104155334-machine\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/machine\/": {
        
        "title": "Machines",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/machine\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/": {
        
        "title": "Mains",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/merge_sort\/": {
        
        "title": "Merge-sort",
        "tags": ["algorithm",],
        "content": "a Divide \u0026amp; conquer algorithm to sort a seq.\nAlgorithm 1. [devide] Represent the original seq by seq1 and seq2, where seq1 is seq[0..n/2], seq[n/2+1..n]\n2. [conquer]  [trivial condition] for a seq with 1 item, it\u0026rsquo;s sorted self is it self  3. [combine] merge compare car of 2 ordered seq. if sorted desc.ly, append the largest one to the end of the result list.\nProof devide and conquer is trivial for merge-sort.\n[combine] merge  objective: ensure that the result is strictly desc. (if sort desc.)  -\u0026gt; ensure that the appended element is the correct one  correct one: smaller than before, larger than after   -\u0026gt; ensure that the appended element is the largest in both seq1 and se2  [provided] seq1 and seq2 is sorted desc.  -\u0026gt; car of seq1 and seq2 is larger than cdr or seq1 and seq2 -\u0026gt; if car(seq1) \u0026gt; car(seq2), car(seq1) is larger than all ELT in seq2.   ensured.   ensured.    Code Example (defun devide (seq)  \u0026#34;devide a problem into 2 problems. Return the the combined solution of the 2 problems\u0026#34;  (if (or (not seq) \t(= (length seq) 1))  ;; when small enough to swallow  (conquer seq)  ;; otherwise, keep dividing  (my-merge (devide (seq-subseq seq 0 (floor (/ (length seq) 2)))) \t(devide (seq-subseq seq (floor (/ (length seq) 2)))))))  (defun conquer (seq)  \u0026#34;conquer the order of a length 1 seq\u0026#34;  seq)  (defun my-merge (seq1 \u0026amp;optional seq2) ;;merge is defined in cl.el  \u0026#34;merge 2 sorted seq\u0026#34;  (setq result nil)  (while (or seq1 \tseq2)  (if (and seq1 seq2 (\u0026lt; (car seq1) (car seq2))) ;;append have no side-effect \t(progn (setq result (append result (list (car seq1)))) \t(pop seq1)) ;;append take seqs as argument  (progn (setq result (append result (list (car seq2)))) \t(pop seq2)) ;;append take seqs as argument  )  (unless seq2 (progn (setq result (append result seq1)) \t(setq seq1 nil)))  (unless seq1 (progn (setq result (append result seq2)) \t(setq seq2 nil)))  )  result) ;;test (devide \u0026#39;( 9 8 3 5 2 6 8 6 4 3)) ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/merge_sort\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/reference\/meta-learning\/": {
        
        "title": "meta-learning",
        "tags": [],
        "content": "Do research about ways to learn a thing before learning it.\nA principle and stage in learning that the writer Scott Young concluded.\nnarrative Want to learn drawing\nAfter meta-learning should know:\n common pathaway of progressively learning drawing creditable resources/tutorials where to find practice materials; where is better/with what feature benchmark of learning; syllabus; multiple versions. well-known/creditable drills mentioned multiple times. atomic concepts/skills=procedures/facts to tackle  quote  make well-informed decision on how to put up a plan, considering resource available and current best approach/drills, while covering all necessary concept/skill/facts.  ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/reference\/meta-learning\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/20220508095438-note_taking\/": {
        
        "title": "Note-taking",
        "tags": [],
        "content": "Note-taking is a skill and art of writing notes to record one\u0026rsquo;s thinking\nDifferent flow could be seperately declared by:\n Material of reflex  reality(nature) article someone\u0026rsquo;s work tutorial/textbook   Time(context)  in leisure in work(about work) in class   objective  machine (to build a flow) principle (to test) facts plan (project machine)    Jethro\u0026rsquo;s Note taking I read Jethro\u0026rsquo;s How I take notes with Org-roam and was really inspired.\nA good thing is that I do very similar thing like him. The difference is that I aim at being a scholar, with bunch of original ideas(an idea generator!) , but as I\u0026rsquo;m still a student now, I learn from material mostly. Therefore, I could (and will be very happy to) integrate most of his practice without further adjustment into my machine.\nZettelkasten Zettelkasten note is note that:\n is small is context-free is atomic have link in between one another  Writing Zettelkasten note. A well writen Zettelkasten notes looks like this:\n#+title: Note-taking Note-taking is xxxxxxxxxxxxxxx.  *some relevent topics, relation to other concepts title Idealy, the title should be a word that describe the concept very good.\nBut when there\u0026rsquo;s no such word available, a short sentence is also OK\nDescription should be very concise, with high SNR.\nrelevent topics Things grow tricky when coming to sub topics of a concept(topic). Particularly in length.\nSome times a subtopic could very large, with much things to discuss about. In that scenario, could make that subtopic standalone, and replaced the heading with the relation of the subtopic and the current topic.\na example is this node. Writing Zettelkasten note could be far larger a topic than everything else discussed in the node Zettelkasten. When the Writing grow very large, could make it standalone.\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/20220508095438-note_taking\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/machine\/note-taking-machine\/": {
        
        "title": "Note-taking machine",
        "tags": ["machine",],
        "content": "Note-taking machine listed ways I find ensuring principles/outcome and/or specifically tackle circumstances where note-taking could be not intuitive and/or when intuitive approach hides pitfalls.\nMachine Redrafting 3-pass method Taking note while reading articles Taking notes from live lecture Taking notes from video Taking notes from static material (blog,textbook) Notes in direct practice Experiment Research note with emphasis on meta-learning\nLiterature review pitfalls Generally, all notes are good as long as they are relevent, concise, and make sence to me. Yet some really unsatisfying conditions should be avoid.\ncopy large text from source sin:\n generally, a note should be that long. Node like Linear Algebra is a exception. Inside it are small, self-containing nodes, which could standalone very well. Them stacking together save my screen space (they tend to appear together) I don\u0026rsquo;t remember copied large text very well. I don\u0026rsquo;t remember it\u0026rsquo;s meaning, and then have to re-read it again. It might not use a lot of time, but it\u0026rsquo;s very annoying finding things you don\u0026rsquo;t have control over ion your note. I don\u0026rsquo;t remember it\u0026rsquo;s purpose, and it\u0026rsquo;ll be a very dirty nonsence in my note.  outline from index Well, Generally it\u0026rsquo;s considered a well-organized approach to first have a outline exactly like the index, and plan your time according to it.\nHere\u0026rsquo;s how I find it not working:\n  You start copy 1 thing, you start copy another, and you should not copy large text from source. Once you accept the materials largest outline, you might have to accept it\u0026rsquo;s in-chapter outline, and then the paragraph\u0026hellip;\u0026hellip;\nOne thing after another, you\u0026rsquo;ll be forced to copy large texts from source, without further processing, and found you lost your foundation for understanding further content in a garden fall of familiar flowers without names.\n  The writer\u0026rsquo;s organization might not work for you, especially in the first pass. when lack experiance with a field, one can\u0026rsquo;t really understand what\u0026rsquo;s behind the name of the chapters. Some are intuitive, some are strange, some are conflict. Forcing yourself to understand what the writer think is sometimes misleading. It\u0026rsquo;s better to consider the truths themselves.\n  and here\u0026rsquo;s my suggestions for using outlines:\n [checklist] Use it as checklist item, as you still need to start/end somewhere, and have progress track. [atom] break the outline into the smallest pieces, and rearrange them to your liking. [evaluating] treat it as a work of classmate and not holy rules, evaluate where of it looks good and where is strange.  Try to understand the author/lecturer rather than the knowledge when note from a book/lecture, we are tricked into repeating the words from the lecturer.\nAll description provides dimensions and point of view. Not necessarily accurate or consistant. ref/jargon issue.\nDirectly go for the knowledge is better. The objective is understand no one but knowledge.\nVery long, detailed note, providing too much justification rather than observation Like in this page. I gotta rearrange it someday.\nBad for  Difficult to read. usually not justified well, making the observations not reliable hiding useful information little use justification in some notes. too trival.  Not reviewing/rearranging the notes a big problem of mine is that I don\u0026rsquo;t do a thing twice.\nGenerally, I think of doing a thing as 1 time in the future 30. It\u0026rsquo;s logical that I don\u0026rsquo;t do things perfectly in the first run. But the ugly outcome often prevent me from reviewing or manipulating it again\nsource and attribution This machine borrowed vastly from Jethro Kuan\u0026rsquo;s way of note-taking. (print org-capture-templates)\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/machine\/note-taking-machine\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/20220328151029-operating_system\/": {
        
        "title": "Operating System",
        "tags": [],
        "content": "The Info comes most from MITOCW\nMIT 6.S081 meta 6.s081. a website. qemu, a hardware simulation under linux xv6, a teaching OS, on RISC-V processor\nOverview What Operating system do  Abstract Hardware Multiplex Isolation Sharing Security access Preformance Range of application  orgnization Image Kernel have filesystem, process management, memory management\u0026hellip;codes.\n filesystem: give more high-level way to name files, orgnize directories,etc. process management: vi, cc are like different processes, and we want then to run concurrently, without interfering each other. memory: and we divide and allocate memory to them.  API - kernel fd = open(\u0026quot;path\u0026quot;,1) much like defining a funciton, but system calls jump into kernel and run kernel code. The kernel code have the special access to hardware and other kernel code user-defined function don\u0026rsquo;t have\nWhy OS is interesting?  OS have it\u0026rsquo;s projection into all softwares    Tensions\n efficient - abstract   powerful - simple    flexible - secure\nwant the user code to as flexible as possible, but don\u0026rsquo;t want them to subatage other programs.\n      the interaction of funcitons OS provided\nfork() create a new process that is a copy of the currrent one, then how will the resources this process accesed interact with this copy?\n   The infrastructures and services   Tracking bugs  Example of system call - what it looks like?   Installing xv6\n   installing i386 elf  with macport installed sudo port install i386-elf-gcc\n      Simple program\n#include \u0026#34;kernel/types.h\u0026#34;#include \u0026#34;user/user.h\u0026#34; int main(){  char buf[64];   while(1){  int n = read(0,buf,sizeof(buf)); //0 console input, 1 console output by shell.  //buf is a pointer to a memory address where the program ask the OS to read the data into. it\u0026#39;s a reserved 64 cells on the stack.  //sizeof(buf) is the maximum read size.  if(n\u0026lt;=0) break;  write(1,buf,n);  }  exit(0); } chapter 2 of the xv6 book have a table of all system call args.\n    Fork()\nit created 1 identical children process, return the pid of the process, and return 0 if used in the children process. The copy doesn\u0026rsquo;t start/stop corresponding to where the fork() system call is used, but the whole process, and the only difference of the 2 process, is the pid, and what fork() would return.\nthe memory\u0026rsquo;s the same. in different memory\n    exec()\nreplace the current process\u0026rsquo;s memory entirely, and never return. return only under error.\nint main(){  char *argv[] = {\u0026#34;echo\u0026#34;,\u0026#34;this\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;echo\u0026#34;,0}; //0 to signify the end of the array  //each \u0026#34;sth\u0026#34; is a pointer pointing to a address storing the bytes. 0 points to NULL. when pointer\u0026#39;s value is 0, it\u0026#39;s a NULL pointer.  exec(\u0026#34;echo\u0026#34;,argv);  printf(\u0026#34;exec failed!\\n\u0026#34;);  exit(0); } shell use forkexac to execute a command on the fork() of it, and then regain control when the child process exited\n    redirection\nint main(){  int pid;   pid = fork();  if(pid == 0){  close(1);  open(\u0026#34;output.txt\u0026#34;, O_WRONLY | O_CREATE);  char *arg[]={\u0026#34;echo\u0026#34;,\u0026#34;This\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;echo\u0026#34;,\u0026#34;redirected\u0026#34;,0};  exec(\u0026#34;echo\u0026#34;,argv);  printf(\u0026#34;exxec failed\u0026#34;);  exit(1);   } else {  wait((int *) 0);  }  exit(0); } after close(1);, file descriptor 1 is closed. open(\u0026quot;output.txt\u0026quot;,) will bind the lowest number of available file descriptor(1) to output.txt\n  OS organization to check prime pipe: in fork, it will have 4 ends. concurent\nisolation strong isolation between OS and app. So OS won\u0026rsquo;t crash with error of app\n  If there\u0026rsquo;s no OS?\nno multiplexing. The dead loop will continue to run to the end of time so we want the app to give up cpu once in a while\nalso, with memory, the perculating of echo and shell. echo can\u0026rsquo;t overwrite shell\u0026rsquo;s physical memory\n    OS\u0026rsquo;s perpose\n enforce strong isolation enforce multiplexing      Unix Interface\nAbstract the HW resource like process. process system calls act on the abstraction of process, not directly to CPU. So the kernel could allow multiplexing of CPU.\nThe kernel would force the idea that a process won\u0026rsquo;t be able to run for \u0026gt;100ms. exec() is abstraction of memory. The file it works with act like a part of program working memory, which have no physical correspondance with a partucular location.\nfile() abstract disk blocks. You can\u0026rsquo;t directly read or write. The OS have its way to map the files to disk locations, and make sure the file in that block is unique system-wise. Other people can\u0026rsquo;t know/access it.\n    OS should be defensive\n app can\u0026rsquo;t crash the OS app can\u0026rsquo;t break the isolation      typical: HW support\nto strong isolation.\n  user/kernel mode\n  user mode\nonly unpriveleged instructions add sub\n    kernel mode\npriviledge of instructions. manitulating hw directely setting up page table disable clock interupt\n      page table/virtual memory\n  page table\nmap virtual addr to physical addr vew on memory basic idea: give every process its own page table. so that the process don\u0026rsquo;t have knowledge of others physical memory strong memory isolation\n        Entering kernel\nsometimes we want to transfer control to kernel in user app. ecall(n) n is a number of system call number enter kernel at a entry point\nfork() = ecall(n) n is the system call number of fork it goes in the kernel, in a file called syscall.c, in which it checked the number, and then call the function\n    trusted computing base (TCP)\n kernel have no bug kernel treat software as malicious    kernel design\n  monolithic kernel design\nall OS code in kernel mode\n serious bug tight integration - high performance large more(historical reason)      microkernel design\n some in kernel mode  ipc vm multiplex   bulk of OS run in user mode fewer bugs use msgs. Shell -msg- ipc -msg- FS -msg- ipc -msg- Shell performance  jumping tight integration   embeded more          Makefile of xv6\nproc.h -gcc- proc.s -assembler- proc.o -ld- kernel (all the *.o files load together) a kernel.asm is gnerated to see the full form of kernel.\nThe qemu enulate a board of risc5 schema board. Should think it that way. It\u0026rsquo;s a c program of for loop\n  kernel/user mode system call the above in xv6 Page Tables (virtual memory) Inbox hold and wait condition to prevail\nMutual exclusion Scheduling  Round Robin Scheduling Algorithm  the Dinosaur book Introduction What is OS?   Kernel\na program runing all the time\n System programs part of OS but not in kernel Middleware set of software framework provide additional servises graphic, database, multimedia    Computer-System Operation   Bootstrap program(firmware)\n to start the computer in ROM or EEPROM locate OS Kernal and load it into Memory     Kernel start    System process\n after kernel start, it would start some system processes(system daemons) They run while kernel is runing After this, the whole system is booted. The system then wait for event to occur      Interupt\n Interupt signal the event Trigered by:  hardware: sending signal to CPU software: system call (monitor call)   After interupted, CPU:  Stop what it\u0026rsquo;s doing Transfer execution to a fixed point      Interupt Vector\nA table holding some commonly used interupt service for some devises\n    Operating-System Structure Processes Process Program in execution Program = xx.exe. Process = that thing in memory after you load xx.exe into memory\n  Composition\n  Text section: program code Program counter: the current activity Stack: temporary data(like funciton parameter.etc) Data section: global vars Heap: dynamically allocated memory    States As the program executed, the states change. states: new,ready,running,waiting,terminated\n new: the process is created running: instructions are being executed waiting: the process is waiting some event to occur like I/O or siganl Ready: the process is waiting to be assigned to a processor terminated: the process has finished execution   Queues Queue is where process is put when not executing Dispatch: selected to exec\n  I/O request queue    Ready Queue\ncontains all processes ready to exec. Waiting for CPU Each Process is represented with PCB in Ready Queue Generally a linked list\n header: contains pointer to 1st and final PCB.  Each PCB have a field pointing to next PCB\n  PCB Process Control Block(task control block) is the representation of Process\n  Process state as in States Program Counter: Address of next instruction to exec for this proc. Registers: The condition of all registers of that CPU execing the Proc. When Interupt comes, Program Counter and Registers are stored, so that when it\u0026rsquo;s back on the table, they could continue. CPU scheduling information:(more in CPU Scheduling)  process priority pointer to scheduling queues other scheduling parameters   Memory-Management information(more in Main Memory) memory stuffs, like page table. Accounting information  amount of CPU real time used time limit account number job/proc number etc   I/O status information  list of I/O devices allocated to the process list of open files    Thread the PCB will be modified to include thread information to support multi thread system\nScheduling   Objectives\n multiprogramming: have something to run always time-sharing: have everything running interactive  to meet these objectves, the process scheduler select proc.\n    Long-term(job) scheduler\nProcess are stored on a disk when first submitted. Job scheduler select from that pool to load into memeory controls the degree of multiprogramimg (how many proc.s in memory)\nselection of process that will be allowd to get in touchwith CPU Influenced by: resource allocation consideration\nsometimes absent, like in unix/ms.\n  careful selection\n Bound:  I/O-bound: more time in I/O CPU-bound: more time in computation   a good process fix: both of them mixed nicely, so that no device is wasted.(no too long queue and empty queue)        Short-term(CPU)\nselect from ready processes to feed CPU Very frequent, least once every 100ms\nselection of 1 process from CPU\n    Medium-term scheduler\nsometimes it\u0026rsquo;s good to swap a proc out. swapping(more in Main Memory)\n    Context Switch\ninclude:\n CPU Registers process state memory-management information  Few ms speed. putting the context in other place, and load the context in the new process\u0026rsquo;s PCB\n  Operations on Process   Creation\nParent proc. create Child proc. Forming a tree, starting from the proc with pid=0\n  Resource Options\n share all resource child use subset of parent\u0026rsquo;s resource share no resource      Execution Options\n concurrently parent wait for child to terminate.        Termination\nProcess use exit() to ask OS to delete it. This:\n return status data from child to parent (0 for normal) cause the resource to be relocated  Parent use wait() to wait for child to finish\n  Parent/Child process   execution\nwait, or concurrently Concurrent is good forL information sharing, computation speedup, modularity, and convenience\n  Coorperating process   interprocess communication mechanism\n  shared memory\nshare some variables\n type of buffer  bounded: fixed buffer size unbounded: no limit on the size of buffer     how to do it?      message passing\n   How?\na message passing facility provide:\n send(message) receive(message)  a communication link must exist between them\n    Direct/indirect communication\nMessages goes into a queue Buffering of the queue:\n Zero capacity Bounded unbounded    Direct Communication\nuse send(P,message) and recieve(Q,message). use pid for the communication (P,Q) hard to find the sender.\n    Indirect\n Create a port A use send(A,message), recieve(A,message) destroy a port        Synchronous/asynchronous communication\nBlocking is synchronous, non-blocking is asynchronous\n Blocking  send: sender is blocked until message recieved recieve: reciever is blocked until recieve message   non-blocking  send: send and go recieve: recieve something or NULL       Automatic/explicit buffering        communication in client-server systems\n  socket\nsocket = endpoint of communication a connection between 2 applications include 2 sockets on each end of communication channel\n    remote procedure call(RPC)\n1 process/thread call procedure on remote application\n    pipes\ntake output of a command as input of another\n    Threads Thread is a stream of instruciton\n Benefits:  less time to create/terminate/switch than proc. better communication efficiency   Representation: Thread Control block  Thread ID Program counter: which instruciton next Register set: current working variables Stack: history of thread execution other things it share with other threads in the proc.    Multicore Programming   Concurrency / Parallelism\n Concurrency: Overlaped executing period. Parallelism: Multicore multitasking.    Multithreading Models   User level threading\nsome software library with threading util take care of that.\n Pro  No mode switiching -\u0026gt; fast cross-OS flexible. We can write the scheduling algor. ourselves.   Con  system calls block for process. All thread in the process will be blocked altogether. only concurrecy, not parallelism. only 1 processor.       Kernel level threading    Many to One Model\nThread library do the thread in user space\n    One-to-One model\nKernel knows. Each user thread map into 1 kernel thread\n  Thread Libraries Implicit Threading Threading issues/Design method Process Synchronization CPU Scheduling Deadlocks Main Memory Virtual Memory Mass-Storage Structure File-System Interface File-System Implement I/O Systems Protection Security Virtual Machines Distributed Systems Trying Machine Thread Thread stream of instruciotn flow of control in a process\nPros of Thread  Responsiveness have 1 thread doing a very difficult job other threads works normal, and interact immediately Resource sharing thread of 1 process share the memories without explicit specification Economy faster in creation and context switch due to resource sharing Scalability can run faster on multicore systems. while 1 thread process runs the same on multicore or singlecore.  Thread Control Block  thread ID program counter register set stack  Sequential/Multi-threaded program  Sequential program: program with only 1 stream of instruction multi-threaded program: program with n streams of instruction  single/multi-threaded processes  single thread process: traditional process multithreaded process: same code, data, file. but multiple threads. Perform more than 1 task at time  Thread life cycle   Preemption  Amdahl\u0026rsquo;s law \\(speedup \\le \\frac{1}{S + \\frac{(1 - S)}{N}}\\) where S stands for serial parts of the program the law states:\n the speed up rise with N(core number) rise the speed converge to \\(\\frac{1}{S}\\) as N approach \\(\\inf\\).  Challenges with multicore programming  Identifying Tasks find areas that can be devided into concurrent threads They should be independent. Balance some task are too small to run seperately. like x = x + 1. Data splitting the data accessed should be devided to corresponding processors. Data dependency when proc1 depend on the result of proc2. They should be synchronized, so that the data is used right. Testing and debugging The possible order of instruction execution increase largely when concurent.  Concurrency/Parallelism  Concurrency: little bit of every one parallelism: more cores.    types of parallelism\n data parallelism data is divided to cores for identical operation array1.sum() =\u0026gt; array1[:5].sum() + array1[5:].sum() Task parallelism unique operation to cores    Synchrounous threading   fork-join strategy\nparent fork child, and wait for them all to terminate. data sharing is significant. The parent may use all the data child manipulated.\n  Threading Support   User level libraries\nlibrary create and manages threads program -libs-\u0026gt; multiple little threads scheduled -\u0026gt; new program -\u0026gt; load as process -\u0026gt; single threaded process on 1 core.\n  pro\n no mode switching -\u0026gt; fast options for scheduling not OS specific      con\n the blocking system calls would block the whole process, and threfore all threads of the process no parallelism        Kernel level\nkernel create and manages, schedules threads.\n  pro\n use multiple cores blocking at thread level multithread kernel routines(everybody multithread)      con\n thread switch always involves kernel -\u0026gt; mode switch -\u0026gt; slower      lightweight process an intermediate data structure between user and kernel threads\n to user: virtual processor to kernel: attach to a kernel therads when blocking happens: block on thread level, not process. could use multiple cores.  multithreading models   M to O\nwith Thread librarys. the functions in the library schedule the threads into 1 large thread, feeding to 1 kernel thread.\n    O to M\neach user thread map to one kernel thread. concurrency, clever blocking. the overhead could be troublesome, so often the number of threads are restricted\n    M to M\na set of threads map to a set of kernel therad with less or equal degree. Therefore unlimited user threads, concurrency and clever blocking.\n    2 level\nM to M + O to O side by side.\n  Thread libraries lib that provide functions to create use terminate therads\n  Thread API\nFunctions and Data structure of the thread library. like future, thread.\n    POSIX\n Pthread     Java   Win32    Implementation\n in user space: local function call codes and data structure in user space kernel level: system call codes and data structure in kernel space    Asynchronous/synchronous threading  Asynchronous: parent don\u0026rsquo;t wait child synchronous: parent wait child.  Explicit/Inplicit threading   Explicit threading\nProgrammer create and manage the threads\n    Inplicit threading\ncompilers and run-time libs create and manage threads\n  Thread pool\na pool of threads init at process init. They sit and wait for work. when works come, 1 thread will be call from the pool, and return after the work done.\n    OpenMP\nset of compiler directives for C,C++,Fortran, that instruct compiler to generate parallel code automatically. parallel region is idendtified with the directives.\n  parallel region\n#include \u0026lt;omp.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]){  #pragma omp parallel //the parallel region  {  printf(\u0026#34;I am a parallel region.\u0026#34;);  }  return 0; }       Grand Central Dispatch\nextension to C and C++ on macOS and iOS to support parallelism it use\n  blocks\n^{printf(\u0026quot;hi\u0026quot;);}\n    dispatch queue\nblocks as unit, go in that queue. when block removed, the block goes to a thread.\n queue types:  serial: FIFO, 1 by 1 concurrent: FIFO, n by n. there\u0026rsquo;s 3 concurrent queue with different priority.        main queue\nevery process have this serial queue\n      asynchronous procedure call (APC) fork() create a new child thread from the parent thread. an identical copy.\n child/parent thread  exec() replace the executable of the thread. others stay the same.\n interaction of exec() and fork()  signal handling a interrupt or event generated by a unix system in response to a condition/actoin\n  signal handler\nthe function handling the signal all signals are handled exactly once\n    asynchronous signal\nfrom outside the process that receives it\n    synchronous signal\nfrom the same process\n  thread cancellation  target thread    Asynchronous cancellation\nterminate the target thread immediately\n    Deferred cancellation\nthe target thread periodically check if it should be terminated. the canceled thread has sent the cancellation request\n cancellation point   cleanup handler    single- to multi-thread Thread-local storage (TLS) Scheduler Activations (lightweight process)  upcall   upcall handler  Linux thread story Process Synchronization coordination of process manageing the execution of processes so that no 2 processes access same resource the same time\nshare resource critical-section problem   critical section\nthe area where the shared data is accesed\nto ensure the correctness, the logical parallelism is turned off in critical section.\n    entry section\ncode entering critical section\n    exit section\ncode leaves critical section\n    remainder section\ncode other than the above 3 sections.\n    solution\n  requirement\n  Mutal Exclusion\nonly 1 process is in critical section.\n    Progress\nwhen 0 process is in critical section, someone could get into critical section. when 2 process competeing, 1 must win.\n    Bounded waiting.\nthe waiting time should be limited. 1 process would lose,lose,lose\u0026hellip;win!\n      software\nrely on algorithms ensuring only 1 process in critical section. since CS is untouchable, use entry and exit section to build the system.\n  Peterson\u0026rsquo;s Solution\nby Gary L. Peterson in 1981 between 2 process P0 and P1\nint turn; //whose turn it is to enter boolean flag[2]; //init to FALSE. flag[i] = TRUE -\u0026gt; Pi is ready.   Peterson\u0026rsquo;s Algorithm\ndo {  //entry section start  flag[0] = true; //P0 ready  turn = 1; //give away turn  while (flag[1]\u0026amp;\u0026amp;turn==1); //wait while P1 is ready and having its turn  critical_section();  //entry section end  flag[0] = false; //exit section  //remainder section.  } while (true);       cons\n complicated to program busy waiting(CPU wasted) it\u0026rsquo;s better to just block the waiting process. but that involves OS        hardware\nrely on machine instruction of Locks\n  Locks\nlock on the required resource at entry section remove lock at exit section\n Test and Set solution    compare and swap\nthe Pi finds lock = 0 proceed. Pi lock other proc by setting lock = 1. at exit, Pi set lock = 0 to enable progress.\n      pro\n scalable. work on n proc. on n cores. simple multipel CS supported      con\n busy-waiting    starvation\ninfinite blocking 1 proc leave CS, multiple waiting.\n    deadlock\niofinite waiting to a signal from the other. priority. High priority will obtain processor, while the current proc. don\u0026rsquo;t have one to exit CS\n        OS and PL solution\nprovide function/stucture to use for synchronization\n    Mutex lock/Mutual Exclusion\napply lock at entry, remove lock at exit. block proc. asking for lock while the lock is unavailable\n  kernel-level\ndisable interupts\n    software-level\n  busy waiting(spinning)\nconstantly check if a lock is available.\n     spinlock      Semaphores\nSemaphore is a Integer var, that is only accessed by wait() and signal().\nwait(){  while(signal\u0026lt;=0);  signal--; } siganl(){  signal++; } by init signal to n, enable n processes into CS at same time.\n  counting semaphore\nsemaphore goes to n for resource having multiple instances\n    binary semaphore\nsemaphore init to 1\n   issue with semaphore      atomic instuction instruction that is not interuptable.\nPreemptive/nonpreemptive kernel multiprogramming Synchronization hardware Race condition the condition that multiple proc.s manipulate same shared data concurrently. final value depends on the random order of the manipulation.\nTo prevent race condition, concurrent processes must be synchronized\nclassical process-synchronization probelms   The Bounded-Buffer / Producer-Consumer Problem\n     The Readers–Writers Problem\nn readers, n writers. readers read, writers write. write: only 1 writer access the shared data. read: all reader and non writer can access the shared data use a reader-writer lock that specify the mode of lock.\n    The Dining-Philosophers Problem\n   solutions\n allow only 4 philosopher to be hungary together allow pickup only if both chopsticks available(in CS) odd # philosophers pick left chopstick 1st Even # philosopher always picks up right chopstick 1st      Monitor CPU Scheduling concepts   Execution phases of a process\ninterleaved with cpu-burst and io-burst\n    CPU-I/O Burst Cycle\neach process is build up with interleaved cpu-burst and io-burst.\n    Type of I/O Processes\nwhether the process is I/O bound or CPU bound determined the apropriate scheduling algorithm\n  I/O bound\nmany short cpu burst mostly waiting for I/O affect user interaction.(word processor/emacs)\n    CPU Bound\nfew long cpu burst I/O very few long cpu burst helps could do with lower priority(3d rendering, machine learning)\n      Preemptive/non-preemptive Scheduling\n preemptive: the OS can stop execution of the running process on cpu non-preemptive: the OS can\u0026rsquo;t stop the current process. Must wait until it exit.      CPU Schedulers\n Trigger:  timer interrupt running process blocked by I/O By means of state change:  Running to Ready [interrupt] preemptive Running to Waiting [I/O request/wait()] non-preemptive Waiting to Ready [I/O complete] preemptive * to Terminate non-preemptive     deed:  triggered pick another process from ready queue perform context switch        Dispatcher\nhand in control of CPU to the selected process(by short-term scheduler) called in every process switch\n switch context switch to user-mode jump to the execution location in the program    dispatch latency\ntime of dispatcher stop and start process.\n    criteria  Max CPU utilization – keep the CPU as busy as possible Max Throughput – complete as many processes as possible per unit time Fairness - give each process a fair share of CPU Min Waiting time – process should not wait long in the ready queue Min Response time – CPU should respond immediately  algorithms   Terms\n  Arrive Time\npoint of process arrives in the ready queue    Completion Time\npoint of process complete execution\n    Burst time\nduration required by a process for CPU execution\n    Turnaround time\nduration of | 1st time into ready state -\u0026hellip;-\u0026gt; complete | turnaround time = Completion time - Arrive time\n    Waiting Time\nduration of process waiting in ready queue Waiting Time = Turnaround Time - Burst Time\n    Response Time\nPoint of process gets CPU for the 1st time\n      Algors\n  First-Come, First-Served (FCFS) Scheduling\n first-come, first-served waiting time high      Shortest-Job-First (SJF) Scheduling\nwithout preemption aims at shortest burst time\n  estimate next burst time\ne = estimated time t = actual time a = weight factor (1 \u0026lt; a \u0026lt; 0)\n\\(e_{n+1} = at_n +(1-a)e_{n}\\)\n    pro\n min average waiting time min average response time      con\n not practical: burst time unknown so SJF cannont be implemented at short term scheduling level starve long job.        Shortest Remaining Time First (SRTF) Scheduling\n When the new-comer have the shortest burst time, switch to him.      Priority Scheduling\n Each process assigned a priority  based on:  OS criteria(memory\u0026hellip;) admin\u0026rsquo;s choice     cpu allocated to highest priority Probelm:  Starvation: low priority never exec.  solution: aging.          Round Robin(RR) Scheduling\n a quantom of time q for everyone q of P1, then q of P2\u0026hellip;.    Performance\n large q: FCFS small q: cost of overhead. Large compared with context switch.        Multiple-Level Queues Scheduling\n Ready queue partitioned (permanantly) into 2 queues:  Foreground Proc Background Proc   Schedule in 2 types:  To the Queues In the Queue   Among the Queues:  Fixed Priority Scheduling first forground, then backgound Time slice 80% time Forground in RR, 20% time Background in FCFS   Categories of Proc: in them the priority desc  Interactive processes Non-interactive processes CPU-bound processes I/O-bound processes Background processes Foreground processes        Multilevel Feedback Queue Scheduling\nplace process into priority queues based on their CPU burst behaviour\n IO higher, CPU lower Basic Rules:  New proc. highest priority quantum finished: (if proc not finish) into next lower queuef   Parameters  n queues scheduling algorithem for each queue upgrade method demote method queue select method   Example  Q1: RR 8ms Q2: RR 16ms Q3: FCFS        Thread Scheduling\n  contention scope\nthe scope where the user threads compete for use of physical CPU\n  Process Contention Scope PCS (unbound thread)\nlocal. many-to-one\n    System Contention Scope SCS (bound thread)\nglobal one-to-one\n        Multiple-Processor Scheduling\n  inside Multiprocessor OS\n Require different inter-proc. comminucation \u0026amp; synchronization techniques All processors share a memory          \u0026lt;!--list-separator--\u0026gt; - 3 structures \u0026lt;!--list-separator--\u0026gt; - Separate Kernel Configuration every Processor have it's own I/O device and file system little interdependency - no parrallel execution \u0026lt;!--list-separator--\u0026gt; - Master–Slave Configuration (Asymmetric Configuration) 1 master processor and other slave processors OS run by master process scheduling run by master \u0026lt;!--list-separator--\u0026gt; - Symmetric Configuration Any processor can access any device and can handle any interrupts generated on it. Mutual Exclusion for the OS is required. OS is seperated into independent parts. to prevent concurrency \u0026lt;!--list-separator--\u0026gt; - approaches \u0026lt;!--list-separator--\u0026gt; - common ready queue \u0026lt;!--list-separator--\u0026gt; - per-core run queues \u0026lt;!--list-separator--\u0026gt; - Process Affinity caches make 1 processor more \u0026quot;familier\u0026quot; for a process. So it's better to use 1 processor all along. \u0026lt;!--list-separator--\u0026gt; - soft affinity no guarentee \u0026lt;!--list-separator--\u0026gt; - hard affinity allowing a \u0026lt;!--list-separator--\u0026gt; - Load Balencing for each core's queue \u0026lt;!--list-separator--\u0026gt; - Push migration when too long, push task to other processor's queue \u0026lt;!--list-separator--\u0026gt; - Pull migration when empty ready queue, read from othre processors' queue. Transfer them into my own queue \u0026lt;!--list-separator--\u0026gt; - Multicore Processors a core executes a thread a time \u0026lt;!--list-separator--\u0026gt; - Memory stall single-core processor waiting for the data to become available. use that time to execute other thread. \u0026lt;!--list-separator--\u0026gt; - Hyperthreading a intel technology a physical processor divieded into 2 logical processors that are treated like seperate physical processors. \u0026lt;!--list-separator--\u0026gt; - Multithreading multiple thread on same core \u0026lt;!--list-separator--\u0026gt; - coarse-grained switch thread only when 1 thread block \u0026lt;!--list-separator--\u0026gt; - fine-grained scheduling in Round Robin policy \u0026lt;!--list-separator--\u0026gt; - Real-Time CPU Scheduling \u0026lt;!--list-separator--\u0026gt; - Real-time system a system where time play important role \u0026lt;!--list-separator--\u0026gt; - hard real-time system must meet deadline \u0026lt;!--list-separator--\u0026gt; - soft real-time system desirable not not necesary \u0026lt;!--list-separator--\u0026gt; - aperiodic tasks irregular arrival time \u0026lt;!--list-separator--\u0026gt; - periodic tasks once per period T \u0026lt;!--list-separator--\u0026gt; - Scheduling real-time tasks  \u0026lt;!--list-separator--\u0026gt; - interrupt latency determine interrupt type switch context \u0026lt;!--list-separator--\u0026gt; - dispatch latency \u0026lt;!--list-separator--\u0026gt; - Static Scheduling schedule prepared before app startup \u0026lt;!--list-separator--\u0026gt; - Priority-based scheduling priority assigned base on how quickly it must react \u0026lt;!--list-separator--\u0026gt; - Dynamic scheduling schedule change over time. \u0026lt;!--list-separator--\u0026gt; - timing constraints - period: - deadline: - \u0026lt;!--list-separator--\u0026gt; - scheduling criteria - timing constraints met - cost of context switch, while preempting, must be reduced - \u0026lt;!--list-separator--\u0026gt; - preemptively/non-preemptively, staticly/dynamically \u0026lt;!--list-separator--\u0026gt; - Rate-Monotonic Scheduling static priority-based preemptive scheduling algorithm shortest period = highest priority \u0026lt;!--list-separator--\u0026gt; - Earlies-Deadline-First Scheduling deadline - priority dynamically assign priority according to deadline \u0026lt;!--list-separator--\u0026gt; - Proportional Share Scheduling T shares are allocated to all procs. in the system An app recive N shares. N \u0026amp;lt; T \u0026lt;!--list-separator--\u0026gt; - Process in here periodic. - once the process get CPU, it has: - fixed processing time \\\\(t\\\\) - deadline \\\\(d\\\\) - period \\\\(p\\\\) - \\\\(0 \\le t \\le d \\le p\\\\) - rate \\\\(\\frac{1}{p}\\\\) - illustrate  \u0026lt;!--list-separator--\u0026gt; - Algorithm Evaluation ❑ \u0026lt;!--list-separator--\u0026gt; - Deterministic evaluation 1. define workload: avg waiting time? 2. test. \u0026lt;!--list-separator--\u0026gt; - Queueing Models we define queues for I/O and CPU, then queueing theory comes in handy \u0026lt;!--list-separator--\u0026gt; - little's formula \\\\(n = \\lambda \\times W\\\\) n:average queue length W:avg waiting time \\\\(\\lambda\\\\):avg arrival rate if we know 2 of the parameters, we know the thirs \u0026lt;!--list-separator--\u0026gt; - Simulations trace tapes to provide real machine process to simulate algorithms on.  Deadlock System Model  system have resources. Resource have R types Resource have W Instances Process Use Resource with:  request use release    Deadlock Characterizaiton deadlock arise if the four condition the same time\n  Mutual exclusion\n1 process at a time hold that resource\n    Hold and wait\nthe process holding 1 resource wait for the other one\n    No preemption\nresource released only voluntarily\n    Circular wait\nclosed chain of process waiting for resource from the next one in chain\n    Resource allocation Graph\n     Basic Facts\n graph have no cycle = no deadclock have cycle:  1 instance per resource type = deadclock n instances per resource type: possibilities.      Methods for handling Deadlocks   Deadlock Prevention\ntry to eliminate 1 of the 4 conditions\n  Mutual exclusion\nno\n    Hold and wait\nlimit max resource hold to 1. -\u0026gt; low resource use,\n    No preemption\n when holding 1 asking 1 denyed, release all. or if the asked 1 is held by other, preempt him      Circular wait\norder the resource types. restrict request object to R3-5 after holding R3.\n      Deadlock Avoidence\nconstrain request to prevent least 1 of the 4 conditions.\n don\u0026rsquo;t start dangerous proc. don\u0026rsquo;t grant dangerous request.    safe state\nat least 1 sequence of resource allocation that does not result in deadlock\n    Max need\ntotal amount of each resources\n    available resource\ntotal amount of each unallocated resources\n    need\nfuture request from P1 for R2\n    allocation\nthe R0 and R1 that P1 have been holding.\n    single instance of Resource\n  claim edge\nPi may request Rj. if check cycle, reject, otherwise claim -\u0026gt; request\n      Multiple Instances of REsources\n  Banker's algorithm\n  Data structures\nn = number of process; m = number of resource type; avalable[m] containing instance numbers; Max[n,m]. Max[i,j]=k,then Pi may request at most k instances of Rj; Allocation[n,m];Pi have k of Rjs; Need[n,m];Pi still need k of Rjs. Need[i,j] = Max[i,j]-Allocaiton[i,j]     Safety Test algo\n  init\nWork[m] = available[m]; Finish[n]= false;   find i such that:\n Finish[i] = false Need[i]\u0026lt;=Work[i] if no, goto step 4    work = work + allocation; finish[i]= true;goto step 2\n  if finish[i] = true for all i, then safe state.\n      Resource request algo\npretend to do the request. check that map.\n          Deadlock Detection\n  Detection of single instance of resource\n  wait-for graph\nmerge resource.\n    detection\nsearch for loop in wait-for graph. O(n2)\n      Detection for multiple instances of resources\nbanker\u0026rsquo;s algorithm.\n available   allocation   request      Usage\nwhen? if too late, the deadlock would grow large and hard to deal with\n    Recovery from deadlock   Process Termination / Abort Process\n➢ Abort all deadlocked processes ➢ Abort one process at a time until the deadlock cycle is eliminated\n Order Priority of the process  How long process has computed, and how much longer to completion Resources the process has used Resource\u0026rsquo;s process needs to complete How many processes will need to be terminated Is process interactive or batch?        Resource Preemption\n select victim rollback starvation make sure limited time 1 is a victim    The Project Scheduler My goal is to:\n Gain practical experiance of OS Pass CPT104 OS Concepts with High score  In order to do that, not only I should complete all CPT104 Activities, but also dig in using\n MIT6.S081 I stored thing in my download drive official schedule holds schedule information of the course. the Dinosaur book it contains much practical problems.  The MIT course is in video and practices, and the dinosour book is a book. I plan to use page reading machine on the Dinosaur book and video watching machine on the video materails of MIT.\nI\u0026rsquo;ll be holding Notes in this page, which, will be transformed into blogs in the future on my website.\nKeep that in mind, and knows that there\u0026rsquo;s an audiance. So make them comprehensible, and complete.\npage reading machine Principle   Distributed Exposure\nVarious exposure to the materials build familiarance, the key to memory and understanding/processing.\n    Initiative\nTaking Initiative counters dizziness and copying.\n  Flow  Go through the headings, mark seemed important keywords to headings after the first skim, go to the notes and try to explain them. When failed, check the text. [[]] juicy jargons along the way after current node done\u0026hellip; navigate to the first link(C-c C-x C-p) Create and edit the node Refile it to where it belong(C-c m) Back to the point using org-mark-ring-goto(C-c 5) Go to next link(C-c C-x C-n) Repeat step 4-7 until all links are pointing to somewhere.  video watching machine TODOConstructing video watching machine   TODODo a class conventionally, record obstacles.\nGoal - Problem record - Diagnose - Plan - Execution.\n  conventianl watching\n Watch video (Pause video to)Take note of every section Take note of every listed experiance Take note of every code. Try the code myself.    Note\n  Page table\na.k.a, virtual memory.\n  why use Page table? =\u0026gt; Isolation.\nTo implement isolation between programs in a whole bulk of physical memory space.\nAddress space is the idea of an ideal Isolated Senario.\n    Address Space\nGive every process it\u0026rsquo;s own Address space\nillustrate of 3 process having there own address space\nThere are various approaches to implement Address space. Page Table is one approach.\n    Pageing Hardware\nThe hardware structure that supports Page Table, mainly by processor, or MMU\n  Page Table\nIllustrate of paging\n VA: Virtual Address, PA: Physical Address  VA: location of the code from the process\u0026rsquo;s perspective PA: location of the code from main memory\u0026rsquo;s perspective   CPU holds:  satp register: PA, location of page table in main memory. other: VA, location of data or code address.         xv6 vm code+layout          Practice The MIT course provides extensive lab practices. The completion and logging would be stored in MIT 6.S081 Lab Logs\nMIT 6.S081 Lab Logs Lab 1: Unix utils TODOreading xv6 ch1 xv6 system calls    System call Description     int fork() Create a process, return child’s PID.   int exit(int status) Terminate the current process; status reported to wait(). No return.   int wait(int *status) Wait for a child to exit; exit status in *status; returns child PID.   int kill(int pid) Terminate process PID. Returns 0, or -1 for error.   int getpid() Return the current process’s PID.   int sleep(int n) Pause for n clock ticks.   int exec(char *file, char *argv[]) Load a file and execute it with arguments; only returns if error.   char *sbrk(int n) Grow process’s memory by n bytes. Returns start of new memory.   int open(char *file, int flags) Open a file; flags indicate read/write; returns an fd (file descriptor).   int write(int fd, char *buf, int n) Write n bytes from buf to file descriptor fd; returns n.   int read(int fd, char *buf, int n) Read n bytes into buf; returns number read; or 0 if end of file.   int close(int fd) Release open file fd.   int dup(int fd) Return a new file descriptor referring to the same file as fd.   int pipe(int p[]) Create a pipe, put read/write file descriptors in p[0] and p[1].   int chdir(char *dir) Change the current directory.   int mkdir(char *dir) Create a new directory.   int mknod(char *file, int, int) Create a device file.   int fstat(int fd, struct stat *st) Place info about an open file into *st.    cci| int stat(char *file, struct stat *st) | Place info about a named file into *st. |\n   int link(char *file1, char *file2) Create another name (file2) for the file file1.     int unlink(char *file) Remove a file.    fork() create a child process\n  positions\n memory: same content, different location file descriptors: the same      behaviour\n a child process created, with identical everything of the parent process. child process and parent process don\u0026rsquo;t share memory variables [?] whereever the fork() call is at, the whole program is duplicated      returns\n pid of the created child [in parent] 0 [in child]    Tree of child processes\n Since  in child processes, the value of the creating fork() is 0 memory is duplicated for every child.   Therefore  on a leaf child if use pid1=fork() to store the pid, then all processes in the route from root to this child would have pid stored 0.        wait() wait() is companion of fork(), parent block until childs finish.\nexit() File Descriptor it\u0026rsquo;s an integer. like, 0 - standard in, 1 - standard out, 2 - standard error\nread() write() File system Pipe  1 pipe for one way communication. the file  lab1.2: sleep() I see that you need 1 pipe for each direction of communication, 1 for P1 to P2, and 1 for P2 to P1 Otherwise, when P1 finished writing and start to read, it could read the data it just write into the pipe.\nlab1.3: prime()  I see that procedure doing it is not promising: no I see that funciton layer_init don\u0026rsquo;t work well. it don\u0026rsquo;t tell whether the nums are prime. It\u0026rsquo;s key where the child is inited in the recursive calls. it should be not in the while loop for while loop is giving it chance to  #include \u0026#34;../kernel/types.h\u0026#34;#include \u0026#34;user.h\u0026#34;#include \u0026#34;../kernel/stat.h\u0026#34; int main(){  int p1[2];  pipe(p1);  if (fork() == 0){  for(int i = 2;i\u0026lt;32;i++){  write(p1[1],\u0026amp;i,4);  printf(\u0026#34;inited %d\\n\u0026#34;,i);  }  exit(0);  }else  {  child_process(p1);  }  return 0; }  void child_process(int p[2]){  int prime;  int child_p[2];  pipe(child_p);  close(p[1]);  int len = read(p[0],\u0026amp;prime,4);  printf(\u0026#34;prime: %d\\n\u0026#34;,prime);  if (len==0){close(p[0]);exit(0);}  if (fork()==0){  close(p[0]);  child_process(child_p);  } else {  while(1){  int num;  int len = read(p[0],\u0026amp;num,4);  if (len==0){close(p[0]);close(child_p[1]); \twait(0); \texit(0);  } else  if ( num % prime!= 0){ \twrite(child_p[1],\u0026amp;num,4);  }  }  }  }   good recursive concurrent process call sturcure\n every child process have it\u0026rsquo;s own setup -\u0026gt; child_process() fork(), and on the child process, invoke child_process()  Then, the structure would be a lovely:\n   miscellaneous   main(int argc, char* argv[])\n argc: count of args passed by command-line argv: args. typically, for echo hi!, argv[0] = \u0026quot;echo\u0026quot;, argv[1] = \u0026quot;hi!\u0026quot;      how to add program?\n write source code add path to UPROC variable in riscv-2019fall/Makefile recompile with make qemu and the program should be loaded to the shell      in usys.S\nwhat li means in li a7, SYS_sleep?\n    loading sleep\nwrite the code into user/sleep.c, and the Make would take care of later things.\n    page fault!\ninit: starting sh $ sleep sleep wrong number of args!usertrap(): unexpected scause 0x000000000000000f (store/AMO page fault) pid=3 sepc=0x00000000000000fe stval=0x0000000000003038     how large is 1 byte?\na int? a char?\n  Address space ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/20220328151029-operating_system\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/reference\/": {
        
        "title": "References",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/reference\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/20220509210234-relational_database\/": {
        
        "title": "Relational Database",
        "tags": [],
        "content": "Relational Model Relation table with columns and rows records(Tuples) with common attributes\nAttribute named column\n         attribute 1 attrbute 2    Domain allowable values for Attribute e.g: Age ==\u0026gt; Positive Integer\nTuple a row of a relation\nDegree the number of attributes of a Relation\nCardinality number of Tuples in a Relation\nRelation schema Definition of a relation Contains:\n attributes  name domain    Relational database schema A set of relation schemas.\nPrimary key Candidate key Foreign Key Linear Algebra ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/20220509210234-relational_database\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/main\/20211011143205-relational_database\/": {
        
        "title": "Relational Database",
        "tags": [],
        "content": "ca:PROPERTIES: :ID: 916112C1-589D-4FC2-B430-93EB989A1350\nRelational Model Relation table with columns and rows records(Tuples) with common attributes\nAttribute named column\n         attribute 1 attrbute 2    Domain allowable values for Attribute e.g: Age ==\u0026gt; Positive Integer\nTuple a row of a relation\nDegree the number of attributes of a Relation\nCardinality number of Tuples in a Relation\nRelation schema Definition of a relation Contains:\n attributes  name domain    Relational database schema A set of relation schemas.\nPrimary key Candidate key Foreign Key ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/main\/20211011143205-relational_database\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/search\/": {
        
        "title": "search",
        "tags": [],
        "content": " type in the search box  ", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/search\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/tags\/": {
        
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/tags\/"
    },
    
    
    
    "https:\/\/hermanhel.github.io\/braindump\/reference\/well-informed-decision\/": {
        
        "title": "well-informed decision",
        "tags": [],
        "content": "Do research, and then make decision. Make sure the decision is backed with information of reality.\na prinicple from Ray Daleo\n", 
        "url": "https:\/\/hermanhel.github.io\/braindump\/reference\/well-informed-decision\/"
    },
    
}
</script>


<script src="https://hermanhel.github.io/braindump/js/lunr.min.js" type="text/javascript"></script>


<script src="https://hermanhel.github.io/braindump/js/search.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
