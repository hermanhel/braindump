<!DOCTYPE html>
<html><title>Operating System</title>


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />


<link rel="stylesheet" href="https://hermanhel.github.io/braindump/css/main.min.291920189b1189fd3388c38fd9e8ccbdf24640f05f020c32e3da5ba83f9bd5d8.css"/>
<body><header>
    <a href="/" id="logo">
    <svg id="Capa_1" enable-background="new 0 0 511.992 511.992" height="512" viewBox="0 0 511.992 511.992" width="512" xmlns="http://www.w3.org/2000/svg"><g><g><g><path d="m256 420.826c0 38.345-11.844 68.545-49.991 68.014-27.744-.385-51.481-15.31-61.853-39.46-1.239-2.887-4.024-4.734-7.154-4.725-.07 0-.135 0-.201 0-47.474 0-75.537-26.171-75.537-73.882 0-5.633.542-11.138 1.568-16.468.62-3.229-.825-6.489-3.671-8.125-35.493-20.432-49.161-46.127-49.161-90.183 0-44.057 13.668-69.757 49.161-90.185 2.846-1.636 4.291-4.896 3.671-8.13-1.026-5.33-1.568-10.83-1.568-16.463 0-47.711 28.064-73.882 75.537-73.882h.201c3.13.009 5.915-1.837 7.154-4.729 10.372-24.145 34.109-39.069 61.853-39.455 38.15-.532 49.991 29.668 49.991 68.013" fill="#ff9eb1"/></g><g><g><g><path d="m256 91.166c0-38.344 11.844-68.545 49.991-68.014 27.744.385 51.481 15.31 61.853 39.46 1.239 2.887 4.024 4.734 7.154 4.724h.201c47.474 0 75.537 26.171 75.537 73.882 0 5.633-.542 11.138-1.568 16.468-.62 3.229.825 6.489 3.671 8.125 35.493 20.434 49.161 46.128 49.161 90.185s-13.668 69.756-49.161 90.185c-2.846 1.636-4.291 4.896-3.671 8.13 1.026 5.33 1.568 10.83 1.568 16.463 0 47.711-28.064 73.882-75.537 73.882h-.201c-3.13-.009-5.915 1.837-7.154 4.729-10.372 24.145-34.109 39.069-61.853 39.455-38.15.531-49.991-29.669-49.991-68.014" fill="#ff7d97"/></g></g><g><g><path d="m502 265.996c-4.193 0-7.984-2.713-9.407-6.636-1.419-3.912-.16-8.459 3.063-11.092 3.291-2.689 8.009-2.99 11.621-.758 3.568 2.205 5.404 6.578 4.478 10.669-1.02 4.501-5.126 7.817-9.755 7.817z"/></g></g></g><g><path d="m340.83 229.18h-58.013v-58.014h-53.634v58.014h-58.013v53.633h58.013v58.013h53.634v-58.013h58.013z" fill="#faf7f5"/></g></g><g><g><path d="m498.468 291.859c-5.141-2.02-10.945.508-12.965 5.648-6.442 16.389-18.055 28.727-37.649 40.005-6.513 3.746-9.932 11.253-8.505 18.689.921 4.783 1.388 9.686 1.388 14.572 0 41.792-22.662 63.882-65.537 63.882h-.225c-.938 0-1.864.074-2.771.217-15.031-4.92-23.796-20.93-19.661-36.479 1.42-5.337-1.757-10.815-7.094-12.234-5.333-1.418-10.814 1.756-12.234 7.094-5.958 22.405 4.241 45.396 23.384 56.443-9.583 17.791-28.602 28.836-50.748 29.145-11.303.146-19.802-2.743-26.011-8.867-9.184-9.057-13.84-25.592-13.84-49.148v-70h16.816c5.522 0 10-4.477 10-10v-48.014h48.014c5.522 0 10-4.477 10-10v-53.632c0-5.523-4.478-10-10-10h-48.014v-48.014c0-5.523-4.478-10-10-10h-16.816v-70c0-23.555 4.657-40.09 13.841-49.148 6.21-6.123 14.696-9.022 26.011-8.867 23.862.332 44.096 13.132 52.803 33.405.218.509.458 1.003.719 1.483-3.225 8.243-9.084 15.093-16.833 19.574-8.993 5.2-19.465 6.581-29.485 3.89-5.337-1.434-10.819 1.73-12.251 7.064-1.433 5.334 1.729 10.819 7.063 12.252 5.074 1.363 10.221 2.037 15.338 2.037 10.2 0 20.272-2.681 29.346-7.928 11.083-6.408 19.607-16.017 24.616-27.575 41.6.67 63.569 22.718 63.569 63.866 0 4.89-.467 9.794-1.389 14.582-1.427 7.426 1.991 14.933 8.502 18.678 19.572 11.267 31.176 23.584 37.625 39.936 1.552 3.934 5.318 6.334 9.306 6.333 1.221 0 2.462-.225 3.666-.7 5.138-2.026 7.66-7.834 5.634-12.972-7.943-20.141-22.201-35.773-44.801-49.086.967-5.521 1.457-11.155 1.457-16.772 0-52.114-31.48-83.391-84.288-83.876-12.157-26.863-38.963-43.753-70.318-44.189-16.67-.232-30.255 4.688-40.332 14.625-3.813 3.76-7.08 8.226-9.797 13.382-2.717-5.156-5.984-9.622-9.797-13.382-10.075-9.937-23.668-14.852-40.333-14.625-31.353.437-58.158 17.325-70.32 44.189-52.807.485-84.286 31.762-84.286 83.876 0 5.617.49 11.253 1.458 16.771-37.422 22.031-52.724 50.552-52.724 98.008 0 47.451 15.299 75.969 52.721 98.006-.967 5.521-1.457 11.154-1.457 16.772 0 52.114 31.48 83.391 84.288 83.876 12.157 26.863 38.963 43.753 70.318 44.189.377.005.751.008 1.125.008 16.172 0 29.358-4.92 39.207-14.632 3.813-3.76 7.08-8.226 9.797-13.382 2.717 5.156 5.984 9.622 9.797 13.382 9.849 9.713 23.034 14.633 39.208 14.632.373 0 .749-.003 1.125-.008 31.352-.436 58.158-17.325 70.32-44.189 52.807-.485 84.286-31.762 84.286-83.876 0-5.617-.49-11.253-1.458-16.772 22.634-13.329 36.901-28.989 44.838-49.178 2.022-5.14-.507-10.945-5.647-12.966zm-215.652-52.679h48.014v33.633h-48.014c-5.522 0-10 4.477-10 10v48.014h-33.633v-48.014c0-5.523-4.477-10-10-10h-48.013v-33.633h48.014c5.523 0 10-4.477 10-10v-48.014h33.633v48.014c-.001 5.523 4.477 10 9.999 10zm-50.657 230.794c-6.21 6.124-14.717 9.018-26.011 8.867-23.862-.331-44.096-13.132-52.803-33.405-.218-.509-.458-1.003-.719-1.483 3.225-8.243 9.085-15.093 16.833-19.574 8.992-5.2 19.463-6.581 29.485-3.89 5.337 1.434 10.819-1.73 12.251-7.064 1.433-5.333-1.73-10.819-7.064-12.251-15.188-4.08-31.059-1.988-44.684 5.891-11.083 6.408-19.607 16.017-24.616 27.575-41.6-.67-63.569-22.718-63.569-63.866 0-4.89.467-9.794 1.389-14.582 1.427-7.427-1.991-14.934-8.502-18.678-32.183-18.528-44.149-40.621-44.149-81.517 0-40.9 11.966-62.994 44.146-81.517 6.513-3.746 9.932-11.253 8.505-18.689-.921-4.783-1.388-9.686-1.388-14.572 0-41.792 22.662-63.882 65.537-63.882h.225c.938 0 1.864-.074 2.771-.217 15.031 4.92 23.796 20.93 19.661 36.479-1.42 5.337 1.757 10.815 7.094 12.234.861.229 1.726.338 2.577.338 4.422 0 8.467-2.956 9.657-7.432 5.958-22.405-4.241-45.396-23.384-56.443 9.583-17.791 28.602-28.836 50.748-29.145 11.267-.15 19.801 2.743 26.011 8.867 9.184 9.057 13.84 25.592 13.84 49.148v70h-16.816c-5.522 0-10 4.477-10 10v48.014h-48.014c-5.522 0-10 4.477-10 10v53.633c0 5.523 4.478 10 10 10h48.014v48.014c0 5.523 4.478 10 10 10h16.816v70c0 23.554-4.657 40.09-13.841 49.147z"/><path d="m139.699 228.227c-6.766 0-13.186 1.514-18.907 4.31-3.049-8.65-8.286-16.485-15.336-22.673-4.151-3.643-10.469-3.233-14.113.918-3.643 4.15-3.232 10.469.918 14.112 6.711 5.891 10.816 14.143 11.498 22.953-1.213 1.914-2.293 3.946-3.225 6.088-1.145 2.633-2.015 5.316-2.615 8.019-13.414 11.422-33.601 10.834-46.225-1.792-3.906-3.904-10.236-3.904-14.143 0-3.905 3.905-3.905 10.237 0 14.143 10.524 10.524 24.354 15.784 38.193 15.784 8.04 0 16.083-1.775 23.484-5.325 1.904 5.443 4.967 10.557 9.136 15.03.596.639 1.204 1.269 1.826 1.891 1.953 1.953 4.512 2.929 7.071 2.929 2.56 0 5.118-.976 7.071-2.929 3.905-3.905 3.905-10.237 0-14.143-.458-.458-.906-.922-1.342-1.389-6.26-6.716-7.799-15.778-4.118-24.241 2.878-6.616 9.86-13.686 20.826-13.686 5.522 0 10-4.477 10-10 .001-5.522-4.476-9.999-9.999-9.999z"/><path d="m387.667 287.543c-3.905 3.905-3.905 10.237 0 14.143 1.953 1.953 4.512 2.929 7.071 2.929s5.118-.976 7.071-2.929c.622-.622 1.23-1.253 1.83-1.896 4.167-4.471 7.229-9.583 9.133-15.025 7.401 3.549 15.444 5.324 23.484 5.324 13.839 0 27.67-5.261 38.193-15.784 3.905-3.905 3.905-10.237 0-14.143-3.906-3.904-10.236-3.904-14.143 0-12.624 12.625-32.811 13.214-46.225 1.792-.6-2.702-1.47-5.386-2.615-8.019-.932-2.142-2.012-4.175-3.225-6.088.682-8.81 4.787-17.062 11.498-22.953 4.15-3.644 4.561-9.962.918-14.112-3.646-4.151-9.964-4.563-14.113-.918-7.05 6.189-12.287 14.023-15.336 22.673-5.721-2.796-12.141-4.31-18.907-4.31-5.523 0-10 4.477-10 10s4.477 10 10 10c10.966 0 17.948 7.07 20.826 13.686 3.681 8.463 2.142 17.525-4.114 24.237-.44.47-.888.935-1.346 1.393z"/></g></g></g></svg>
  </a>
  <h3 class="site-title">Herman&#39;s place</h3><form id="search"
    action='https://hermanhel.github.io/braindump/search/' method="get">
    <label hidden for="search-input">Search site</label>
    <input type="text" id="search-input" name="query"
    placeholder="Type here to search">
    <input type="submit" value="search">
</form>
</header>

<div class="grid-container">
  <div class="grid">
    <div class="page" data-level="1">
      <div class="content">
        <h1>Operating System</h1>
        <p>The Info comes most from MITOCW</p>
<h2 id="mit-6-dot-s081">MIT 6.S081</h2>
<h3 id="meta">meta</h3>
<p>6.s081. a website.
qemu, a hardware simulation under linux
xv6, a teaching OS, on RISC-V processor</p>
<h3 id="overview">Overview</h3>
<h4 id="what-operating-system-do">What Operating system do</h4>
<ul>
<li>Abstract Hardware</li>
<li>Multiplex</li>
<li>Isolation</li>
<li>Sharing</li>
<li>Security
access</li>
<li>Preformance</li>
<li>Range of application</li>
</ul>
<h4 id="orgnization-image">orgnization Image</h4>
<p><img src="/ox-hugo/os1.png" alt="">
Kernel have filesystem, process management, memory management&hellip;codes.</p>
<ul>
<li>filesystem: give more high-level way to name files, orgnize directories,etc.</li>
<li>process management: vi, cc are like different processes, and we want then to run concurrently, without interfering each other.</li>
<li>memory: and we divide and allocate memory to them.</li>
</ul>
<h4 id="api-kernel">API - kernel</h4>
<p><code>fd = open(&quot;path&quot;,1)</code>
much like defining a funciton, but <code>system calls</code> jump into kernel and run kernel code. The kernel code have the special access to hardware and other kernel code user-defined function don&rsquo;t have</p>
<h4 id="why-os-is-interesting">Why OS is interesting?</h4>
<!-- raw HTML omitted -->
<ul>
<li>OS have it&rsquo;s projection into all softwares</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Tensions</p>
<!-- raw HTML omitted -->
<ul>
<li>efficient - abstract</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>powerful - simple</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>flexible - secure</p>
<p>want the user code to as flexible as possible, but don&rsquo;t want them to subatage other programs.</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>the interaction of funcitons OS provided</p>
<p>fork() create a new process that is a copy of the currrent one, then how will the resources this process accesed interact with this copy?</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>The infrastructures and services</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Tracking bugs</li>
</ul>
<h4 id="example-of-system-call-what-it-looks-like">Example of system call - what it looks like?</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Installing xv6</p>
<!-- raw HTML omitted -->
<ul>
<li>
<ol>
<li>installing i386 elf</li>
</ol>
<p>with macport installed
<code>sudo port install i386-elf-gcc</code></p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Simple program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> read(<span style="color:#ae81ff">0</span>,buf,<span style="color:#66d9ef">sizeof</span>(buf)); <span style="color:#75715e">//0 console input, 1 console output by shell.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//buf is a pointer to a memory address where the program ask the OS to read the data into. it&#39;s a reserved 64 cells on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//sizeof(buf) is the maximum read size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    write(<span style="color:#ae81ff">1</span>,buf,n);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>chapter 2 of the xv6 book have a table of all system call args.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Fork()</p>
<p>it created 1 identical children process, return the pid of the process, and return 0 if used in the children process. The copy doesn&rsquo;t start/stop corresponding to where the fork() system call is used, but the whole process, and the only difference of the 2 process, is the pid, and what fork() would return.</p>
<p>the memory&rsquo;s the same. in different memory</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>exec()</p>
<p>replace the current process&rsquo;s memory entirely, and never return. return only under error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;echo&#34;</span>,<span style="color:#e6db74">&#34;this&#34;</span>,<span style="color:#e6db74">&#34;is&#34;</span>,<span style="color:#e6db74">&#34;echo&#34;</span>,<span style="color:#ae81ff">0</span>}; <span style="color:#75715e">//0 to signify the end of the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//each &#34;sth&#34; is a pointer pointing to a address storing the bytes. 0 points to NULL. when pointer&#39;s value is 0, it&#39;s a NULL pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  exec(<span style="color:#e6db74">&#34;echo&#34;</span>,argv);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;exec failed!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>shell use forkexac to execute a command on the fork() of it, and then regain control when the child process exited</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>redirection</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  pid <span style="color:#f92672">=</span> fork();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>    close(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    open(<span style="color:#e6db74">&#34;output.txt&#34;</span>, O_WRONLY <span style="color:#f92672">|</span> O_CREATE);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arg[]<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;echo&#34;</span>,<span style="color:#e6db74">&#34;This&#34;</span>,<span style="color:#e6db74">&#34;is&#34;</span>,<span style="color:#e6db74">&#34;echo&#34;</span>,<span style="color:#e6db74">&#34;redirected&#34;</span>,<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    exec(<span style="color:#e6db74">&#34;echo&#34;</span>,argv);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;exxec failed&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    wait((<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>after <code>close(1);</code>, file descriptor <code>1</code> is closed. <code>open(&quot;output.txt&quot;,)</code> will bind the lowest number of available file descriptor(1) to <code>output.txt</code></p>
</li>
</ul>
<h3 id="os-organization">OS organization</h3>
<h4 id="to-check">to check</h4>
<p>prime
pipe: in fork, it will have 4 ends.
concurent</p>
<h4 id="isolation">isolation</h4>
<p>strong isolation between OS and app. So OS won&rsquo;t crash with error of app</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>If there&rsquo;s no OS?</p>
<p>no multiplexing. The dead loop will continue to run to the end of time
so we want the app to give up cpu once in a while</p>
<p>also, with memory, the perculating of echo and shell. echo can&rsquo;t overwrite shell&rsquo;s physical memory</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>OS&rsquo;s perpose</p>
<ul>
<li>enforce strong isolation</li>
<li>enforce multiplexing</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Unix Interface</p>
<p>Abstract the HW resource
like process. process system calls act on the abstraction of process, not directly to CPU. So the kernel could allow multiplexing of CPU.</p>
<p>The kernel would force the idea that a process won&rsquo;t be able to run for &gt;100ms.
exec() is abstraction of memory. The file it works with act like a part of program working memory, which have no physical correspondance with a partucular location.</p>
<p>file() abstract disk blocks. You can&rsquo;t directly read or write. The OS have its way to map the files to disk locations, and make sure the file in that block is unique system-wise. Other people can&rsquo;t know/access it.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>OS should be defensive</p>
<ul>
<li>app can&rsquo;t crash the OS</li>
<li>app can&rsquo;t break the isolation</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>typical: HW support</p>
<p>to strong isolation.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>user/kernel mode</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>user mode</p>
<p>only unpriveleged instructions <code>add</code> <code>sub</code></p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>kernel mode</p>
<p>priviledge of instructions. <code>manitulating hw directely</code> <code>setting up page table</code> <code>disable clock interupt</code></p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>page table/virtual memory</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>page table</p>
<p>map virtual addr to physical addr
vew on memory
basic idea: give every process its own page table.
so that the process don&rsquo;t have knowledge of others physical memory
strong memory isolation</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Entering kernel</p>
<p>sometimes we want to transfer control to kernel in user app.
<code>ecall(n)</code> n is a number of system call number
enter kernel at a <code>entry point</code></p>
<p>fork() = ecall(n) n is the system call number of fork
it goes in the kernel, in a file called syscall.c, in which it checked the number, and then call the function</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>trusted computing base (TCP)</p>
<ul>
<li>kernel have no bug</li>
<li>kernel treat software as malicious</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>kernel design</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>monolithic kernel design</p>
<p>all OS code in kernel mode</p>
<ul>
<li>serious bug</li>
<li>tight integration - high performance</li>
<li>large more(historical reason)</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>microkernel design</p>
<ul>
<li>some in kernel mode
<ul>
<li>ipc</li>
<li>vm</li>
<li>multiplex</li>
</ul>
</li>
<li>bulk of OS run in user mode</li>
<li>fewer bugs</li>
<li>use msgs.
Shell -msg- ipc -msg- FS -msg- ipc -msg- Shell</li>
<li>performance
<ul>
<li>jumping</li>
<li>tight integration</li>
</ul>
</li>
<li>embeded more</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Makefile of xv6</p>
<p>proc.h -gcc- proc.s -assembler- proc.o -ld- kernel (all the *.o files load together)
a kernel.asm is gnerated to see the full form of kernel.</p>
<p>The qemu enulate a board of risc5 schema board. Should think it that way. It&rsquo;s a c program of for loop</p>
</li>
</ul>
<h4 id="kernel-user-mode">kernel/user mode</h4>
<h4 id="system-call">system call</h4>
<h4 id="the-above-in-xv6">the above in xv6</h4>
<h3 id="page-tables--virtual-memory">Page Tables (virtual memory)</h3>
<h3 id="inbox">Inbox</h3>
<h4 id="hold-and-wait-condition">hold and wait condition</h4>
<p>to prevail</p>
<h4 id="mutual-exclusion">Mutual exclusion</h4>
<h4 id="scheduling">Scheduling</h4>
<!-- raw HTML omitted -->
<ul>
<li>Round Robin Scheduling Algorithm</li>
</ul>
<h2 id="the-dinosaur-book">the Dinosaur book</h2>
<h3 id="introduction">Introduction</h3>
<h4 id="what-is-os">What is OS?</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Kernel</p>
<p>a program runing all the time</p>
<ul>
<li>System programs
part of OS but not in kernel</li>
<li>Middleware
set of software framework
provide additional servises
graphic, database, multimedia</li>
</ul>
</li>
</ul>
<h4 id="computer-system-operation">Computer-System Operation</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Bootstrap program(firmware)</p>
<ul>
<li>to start the computer</li>
<li>in ROM or EEPROM</li>
<li><code>locate OS Kernal and load it into Memory</code></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Kernel start</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>System process</p>
<ul>
<li>after kernel start, it would start some system processes(system daemons)</li>
<li>They run while kernel is runing</li>
<li>After this, the whole system is <code>booted</code>. The system then wait for <code>event to occur</code></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Interupt</p>
<ul>
<li>Interupt signal the <code>event</code></li>
<li>Trigered by:
<ul>
<li>hardware: sending signal to CPU</li>
<li>software: <code>system call</code> (monitor call)</li>
</ul>
</li>
<li>After interupted, CPU:
<ol>
<li>Stop what it&rsquo;s doing</li>
<li>Transfer execution to a fixed point</li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Interupt Vector</p>
<p>A table holding some commonly used interupt service for some devises</p>
</li>
</ul>
</li>
</ul>
<h3 id="operating-system-structure">Operating-System Structure</h3>
<h3 id="processes">Processes</h3>
<h4 id="process">Process</h4>
<p>Program in execution
Program = xx.exe. Process = that thing in memory after you load xx.exe into memory</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Composition</p>
<figure><img src="/ox-hugo/process.png"/>
</figure>

<ul>
<li>Text section: program code</li>
<li>Program counter: the current activity</li>
<li>Stack: temporary data(like funciton parameter.etc)</li>
<li>Data section: global vars</li>
<li>Heap: dynamically allocated memory</li>
</ul>
</li>
</ul>
<h4 id="states">States</h4>
<p>As the program executed, the states change.
states: <code>new,ready,running,waiting,terminated</code></p>
<ul>
<li>new: the process is created</li>
<li>running: instructions are being executed</li>
<li>waiting: the process is waiting some event to occur
like I/O or siganl</li>
<li>Ready: the process is waiting to be assigned to a processor</li>
<li>terminated: the process has finished execution</li>
</ul>
<figure><img src="/ox-hugo/procstates.png"/>
</figure>

<h4 id="queues">Queues</h4>
<p>Queue is where process is put when not executing
Dispatch: selected to exec</p>
<figure><img src="/ox-hugo/queues.png"/>
</figure>

<!-- raw HTML omitted -->
<ul>
<li>I/O request queue</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Ready Queue</p>
<p>contains all processes ready to exec. Waiting for CPU
Each Process is represented with <a href="#pcb">PCB</a> in Ready Queue
Generally a <code>linked list</code></p>
<ul>
<li>header: contains pointer to 1st and final PCB.</li>
</ul>
<p>Each PCB have a field pointing to next PCB</p>
</li>
</ul>
<h4 id="pcb">PCB</h4>
<p>Process Control Block(task control block) is the representation of Process</p>
<figure><img src="/ox-hugo/pcb.png"/>
</figure>

<ul>
<li>Process state as in <a href="#states">States</a></li>
<li>Program Counter: Address of next instruction to exec for this proc.</li>
<li>Registers: The condition of all registers of that CPU execing the Proc.
When Interupt comes, Program Counter and Registers are stored, so that when it&rsquo;s back on the table, they could continue.</li>
<li>CPU scheduling information:(more in <a href="#cpu-scheduling">CPU Scheduling</a>)
<ul>
<li>process priority</li>
<li>pointer to scheduling queues</li>
<li>other scheduling parameters</li>
</ul>
</li>
<li>Memory-Management information(more in <a href="#main-memory">Main Memory</a>)
memory stuffs, like page table.</li>
<li>Accounting information
<ul>
<li>amount of CPU</li>
<li>real time used</li>
<li>time limit</li>
<li>account number</li>
<li>job/proc number</li>
<li>etc</li>
</ul>
</li>
<li>I/O status information
<ul>
<li>list of I/O devices allocated to the process</li>
<li>list of open files</li>
</ul>
</li>
</ul>
<h4 id="thread">Thread</h4>
<p>the <a href="#pcb">PCB</a> will be modified to include thread information to support multi thread system</p>
<h4 id="scheduling">Scheduling</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Objectives</p>
<ul>
<li>multiprogramming: have something to run always</li>
<li>time-sharing: have everything running interactive</li>
</ul>
<p>to meet these objectves, the <code>process scheduler</code> select proc.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Long-term(job) scheduler</p>
<p>Process are stored on a disk when first submitted.
Job scheduler select from that pool to load into memeory
controls the <code>degree of multiprogramimg</code> (how many proc.s in memory)</p>
<p>selection of process that will be allowd to get in touchwith CPU
Influenced by: <code>resource allocation consideration</code></p>
<p>sometimes absent, like in unix/ms.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>careful selection</p>
<ul>
<li>Bound:
<ul>
<li>I/O-bound: more time in I/O</li>
<li>CPU-bound: more time in computation</li>
</ul>
</li>
<li>a good process fix: both of them mixed nicely, so that no device is wasted.(no too long queue and empty queue)</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Short-term(CPU)</p>
<p>select from ready processes to feed CPU
Very frequent, least once every 100ms</p>
<p>selection of 1 process from CPU</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Medium-term scheduler</p>
<p>sometimes it&rsquo;s good to swap a proc out.
swapping(more in <a href="#main-memory">Main Memory</a>)</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Context Switch</p>
<p>include:</p>
<ul>
<li>CPU Registers</li>
<li>process state</li>
<li>memory-management information</li>
</ul>
<p>Few ms speed.
putting the context in other place, and load the context in the new process&rsquo;s PCB</p>
</li>
</ul>
<h4 id="operations-on-process">Operations on Process</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Creation</p>
<p><code>Parent</code> proc. create <code>Child</code> proc. Forming a tree, starting from the proc with pid=0</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Resource Options</p>
<ul>
<li>share all resource</li>
<li>child use subset of parent&rsquo;s resource</li>
<li>share no resource</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Execution Options</p>
<ul>
<li>concurrently</li>
<li>parent wait for child to terminate.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Termination</p>
<p>Process use <code>exit()</code> to ask OS to delete it.
This:</p>
<ul>
<li>return status data from child to parent (0 for normal)</li>
<li>cause the resource to be relocated</li>
</ul>
<p>Parent use <code>wait()</code> to wait for child to finish</p>
</li>
</ul>
<h4 id="parent-child-process">Parent/Child process</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>execution</p>
<p>wait, or concurrently
Concurrent is good forL <code>information sharing, computation speedup, modularity, and convenience</code></p>
</li>
</ul>
<h4 id="coorperating-process">Coorperating process</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>interprocess communication mechanism</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>shared memory</p>
<p>share some variables</p>
<ul>
<li>type of buffer
<ul>
<li>bounded: fixed buffer size</li>
<li>unbounded: no limit on the size of buffer</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>how to do it?</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>message passing</p>
<figure><img src="/ox-hugo/messagepassing.png"/>
</figure>

<!-- raw HTML omitted -->
<ul>
<li>
<p>How?</p>
<p>a message passing facility provide:</p>
<ul>
<li>send(message)</li>
<li>receive(message)</li>
</ul>
<p>a communication link must exist between them</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Direct/indirect communication</p>
<p>Messages goes into a queue
Buffering of the queue:</p>
<ul>
<li>Zero capacity</li>
<li>Bounded</li>
<li>unbounded</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Direct Communication</p>
<p>use <code>send(P,message)</code> and <code>recieve(Q,message)</code>.
use pid for the communication (P,Q)
hard to find the sender.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Indirect</p>
<ol>
<li>Create a port A</li>
<li>use <code>send(A,message)</code>, <code>recieve(A,message)</code></li>
<li>destroy a port</li>
</ol>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Synchronous/asynchronous communication</p>
<p>Blocking is synchronous, non-blocking is asynchronous</p>
<ul>
<li>Blocking
<ul>
<li>send: sender is blocked until message recieved</li>
<li>recieve: reciever is blocked until recieve message</li>
</ul>
</li>
<li>non-blocking
<ul>
<li>send: send and go</li>
<li>recieve: recieve something or NULL</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Automatic/explicit buffering</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>communication in client-server systems</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>socket</p>
<p>socket = endpoint of communication
a connection between 2 applications include 2 sockets on each end of communication channel</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>remote procedure call(RPC)</p>
<p>1 process/thread call procedure on remote application</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>pipes</p>
<p>take output of a command as input of another</p>
</li>
</ul>
</li>
</ul>
<h3 id="threads">Threads</h3>
<p>Thread is a <code>stream of instruciton</code></p>
<ul>
<li>Benefits:
<ol>
<li>less time to create/terminate/switch than proc.</li>
<li>better communication efficiency</li>
</ol>
</li>
<li>Representation: Thread Control block
<ul>
<li>Thread ID</li>
<li>Program counter: which instruciton next</li>
<li>Register set: current working variables</li>
<li>Stack: history of thread execution</li>
<li>other things it share with other threads in the proc.</li>
</ul>
</li>
</ul>
<h4 id="multicore-programming">Multicore Programming</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Concurrency / Parallelism</p>
<ul>
<li>Concurrency: Overlaped executing period.</li>
<li>Parallelism: Multicore multitasking.</li>
</ul>
</li>
</ul>
<h4 id="multithreading-models">Multithreading Models</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>User level threading</p>
<p>some software library with threading util take care of that.</p>
<ul>
<li>Pro
<ul>
<li>No mode switiching -&gt; fast</li>
<li>cross-OS</li>
<li>flexible. We can write the scheduling algor. ourselves.</li>
</ul>
</li>
<li>Con
<ul>
<li>system calls block for process. All thread in the process will be blocked altogether.</li>
<li>only concurrecy, not parallelism. only 1 processor.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Kernel level threading</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Many to One Model</p>
<p><code>Thread library</code> do the thread in user space</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>One-to-One model</p>
<p>Kernel knows.
Each user thread map into 1 kernel thread</p>
</li>
</ul>
<h4 id="thread-libraries">Thread Libraries</h4>
<h4 id="implicit-threading">Implicit Threading</h4>
<h4 id="threading-issues-design-method">Threading issues/Design method</h4>
<h3 id="process-synchronization">Process Synchronization</h3>
<h3 id="cpu-scheduling">CPU Scheduling</h3>
<h3 id="deadlocks">Deadlocks</h3>
<h3 id="main-memory">Main Memory</h3>
<h3 id="virtual-memory">Virtual Memory</h3>
<h3 id="mass-storage-structure">Mass-Storage Structure</h3>
<h3 id="file-system-interface">File-System Interface</h3>
<h3 id="file-system-implement">File-System Implement</h3>
<h3 id="i-o-systems">I/O Systems</h3>
<h3 id="protection">Protection</h3>
<h3 id="security">Security</h3>
<h3 id="virtual-machines">Virtual Machines</h3>
<h3 id="distributed-systems">Distributed Systems</h3>
<h2 id="trying-machine">Trying Machine</h2>
<h3 id="thread">Thread</h3>
<h4 id="thread">Thread</h4>
<p>stream of instruciotn
flow of control in a process</p>
<h4 id="pros-of-thread">Pros of Thread</h4>
<ul>
<li>Responsiveness
have 1 thread doing a very difficult job
other threads works normal, and interact immediately</li>
<li>Resource sharing
thread of 1 process share the memories without explicit specification</li>
<li>Economy
faster in creation and context switch due to resource sharing</li>
<li>Scalability
can run faster on multicore systems. while 1 thread process runs the same on multicore or singlecore.</li>
</ul>
<h4 id="thread-control-block">Thread Control Block</h4>
<ul>
<li>thread ID</li>
<li>program counter</li>
<li>register set</li>
<li>stack</li>
</ul>
<h4 id="sequential-multi-threaded-program">Sequential/Multi-threaded program</h4>
<ul>
<li>Sequential program: program with only 1 stream of instruction</li>
<li>multi-threaded program: program with n streams of instruction</li>
</ul>
<h4 id="single-multi-threaded-processes">single/multi-threaded processes</h4>
<ul>
<li>single thread process: traditional process</li>
<li>multithreaded process: same code, data, file. but multiple threads. Perform more than 1 task at time</li>
</ul>
<h4 id="thread-life-cycle">Thread life cycle</h4>
<figure><img src="/ox-hugo/threadlifecycle.png"/>
</figure>

<!-- raw HTML omitted -->
<ul>
<li>Preemption</li>
</ul>
<h4 id="amdahl-s-law">Amdahl&rsquo;s law</h4>
<p>\(speedup \le \frac{1}{S + \frac{(1 - S)}{N}}\) where S stands for <code>serial parts of the program</code>
the law states:</p>
<ul>
<li>the speed up rise with N(core number) rise</li>
<li>the speed converge to \(\frac{1}{S}\) as N approach \(\inf\).</li>
</ul>
<h4 id="challenges-with-multicore-programming">Challenges with multicore programming</h4>
<ul>
<li>Identifying Tasks
find areas that can be devided into concurrent threads
They should be independent.</li>
<li>Balance
some task are too small to run seperately. like x = x + 1.</li>
<li>Data splitting
the data accessed should be devided to corresponding processors.</li>
<li>Data dependency
when proc1 depend on the result of proc2. They should be synchronized, so that the data is used right.</li>
<li>Testing and debugging
The possible order of instruction execution increase largely when concurent.</li>
</ul>
<h4 id="concurrency-parallelism">Concurrency/Parallelism</h4>
<ul>
<li>Concurrency: little bit of every one</li>
<li>parallelism: more cores.</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>types of parallelism</p>
<ul>
<li>data parallelism
data is divided to cores for identical operation
array1.sum() =&gt; array1[:5].sum() + array1[5:].sum()</li>
<li>Task parallelism
unique operation to cores</li>
</ul>
</li>
</ul>
<h4 id="synchrounous-threading">Synchrounous threading</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>fork-join strategy</p>
<p>parent fork child, and wait for them all to terminate.
data sharing is significant. The parent may use all the data child manipulated.</p>
</li>
</ul>
<h4 id="threading-support">Threading Support</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>User level libraries</p>
<p>library create and manages threads
program -libs-&gt; multiple little threads scheduled -&gt; new program -&gt; load as process -&gt; single threaded process on 1 core.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>pro</p>
<ul>
<li>no mode switching -&gt; fast</li>
<li>options for scheduling</li>
<li>not OS specific</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>con</p>
<ul>
<li>the blocking system calls would block the whole process, and threfore all threads of the process</li>
<li>no parallelism</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Kernel level</p>
<p>kernel create and manages, schedules threads.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>pro</p>
<ul>
<li>use multiple cores</li>
<li>blocking at thread level</li>
<li>multithread kernel routines(everybody multithread)</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>con</p>
<ul>
<li>thread switch always involves kernel -&gt; mode switch -&gt; slower</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lightweight-process">lightweight process</h4>
<p>an intermediate data structure between user and kernel threads</p>
<ul>
<li>to user: virtual processor</li>
<li>to kernel: attach to a kernel therads</li>
<li>when blocking happens: block on thread level, not process.</li>
<li>could use multiple cores.</li>
</ul>
<h4 id="multithreading-models">multithreading models</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>M to O</p>
<p>with Thread librarys.
the functions in the library schedule the threads into 1 large thread, feeding to 1 kernel thread.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>O to M</p>
<p>each user thread map to one kernel thread.
concurrency, clever blocking.
the overhead could be troublesome, so often the number of threads are restricted</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>M to M</p>
<p>a set of threads map to a set of kernel therad with less or equal degree.
Therefore unlimited user threads, concurrency and clever blocking.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>2 level</p>
<p>M to M + O to O side by side.</p>
</li>
</ul>
<h4 id="thread-libraries">Thread libraries</h4>
<p>lib that provide functions to <code>create</code> <code>use</code> <code>terminate</code> therads</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Thread API</p>
<p>Functions and Data structure of the thread library.
like <code>future</code>, <code>thread</code>.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>POSIX</p>
<!-- raw HTML omitted -->
<ul>
<li>Pthread</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Java</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>Win32</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Implementation</p>
<ul>
<li>in user space: local function call
codes and data structure in user space</li>
<li>kernel level: system call
codes and data structure in kernel space</li>
</ul>
</li>
</ul>
<h4 id="asynchronous-synchronous-threading">Asynchronous/synchronous threading</h4>
<ul>
<li>Asynchronous: parent don&rsquo;t wait child</li>
<li>synchronous: parent wait child.</li>
</ul>
<h4 id="explicit-inplicit-threading">Explicit/Inplicit threading</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Explicit threading</p>
<p>Programmer create and manage the threads</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Inplicit threading</p>
<p>compilers and run-time libs create and manage threads</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Thread pool</p>
<p>a pool of threads init at process init.
They sit and wait for work.
when works come, 1 thread will be call from the pool, and return after the work done.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>OpenMP</p>
<p>set of compiler directives for C,C++,Fortran, that instruct compiler to generate parallel code automatically.
<code>parallel region</code> is idendtified with the directives.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>parallel region</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;omp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#pragma omp parallel </span><span style="color:#75715e">//the parallel region
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;I am a parallel region.&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Grand Central Dispatch</p>
<p>extension to C and C++ on macOS and iOS to support parallelism
it use</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>blocks</p>
<p><code>^{printf(&quot;hi&quot;);}</code></p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>dispatch queue</p>
<p>blocks as unit, go in that queue.
when block removed, the block goes to a thread.</p>
<ul>
<li>queue types:
<ul>
<li>serial: FIFO, 1 by 1</li>
<li>concurrent: FIFO, n by n.
there&rsquo;s 3 concurrent queue with different priority.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>main queue</p>
<p>every process have this serial queue</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="asynchronous-procedure-call--apc">asynchronous procedure call (APC)</h4>
<h4 id="fork">fork()</h4>
<p>create a new child thread from the parent thread. an identical copy.</p>
<!-- raw HTML omitted -->
<ul>
<li>child/parent thread</li>
</ul>
<h4 id="exec">exec()</h4>
<p>replace the executable of the thread. others stay the same.</p>
<!-- raw HTML omitted -->
<ul>
<li>interaction of exec() and fork()</li>
</ul>
<h4 id="signal-handling">signal handling</h4>
<p>a interrupt or event generated by a unix system
in response to a condition/actoin</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>signal handler</p>
<p>the function handling the signal
all signals are handled exactly once</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>asynchronous signal</p>
<p>from outside the process that receives it</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>synchronous signal</p>
<p>from the same process</p>
</li>
</ul>
<h4 id="thread-cancellation">thread cancellation</h4>
<!-- raw HTML omitted -->
<ul>
<li>target thread</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Asynchronous cancellation</p>
<p>terminate the target thread immediately</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Deferred cancellation</p>
<p>the target thread periodically check if it should be terminated.
the canceled thread has sent the cancellation request</p>
<!-- raw HTML omitted -->
<ul>
<li>cancellation point</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>cleanup handler</li>
</ul>
</li>
</ul>
<h4 id="single-to-multi-thread">single- to multi-thread</h4>
<h4 id="thread-local-storage--tls">Thread-local storage (TLS)</h4>
<h4 id="scheduler-activations--lightweight-process">Scheduler Activations (lightweight process)</h4>
<!-- raw HTML omitted -->
<ul>
<li>upcall</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>upcall handler</li>
</ul>
<h4 id="linux-thread-story">Linux thread story</h4>
<h3 id="process-synchronization">Process Synchronization</h3>
<h4 id="coordination-of-process">coordination of process</h4>
<p>manageing the execution of processes so that no 2 processes access same resource the same time</p>
<h4 id="share-resource">share resource</h4>
<h4 id="critical-section-problem">critical-section problem</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>critical section</p>
<p>the area where the shared data is accesed</p>
<p><img src="/ox-hugo/racecondition.png" alt="">
to ensure the correctness, the logical parallelism is turned off in critical section.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>entry section</p>
<p>code entering critical section</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>exit section</p>
<p>code leaves critical section</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>remainder section</p>
<p>code other than the above 3 sections.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>solution</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>requirement</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Mutal Exclusion</p>
<p>only 1 process is in critical section.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Progress</p>
<p>when 0 process is in critical section, someone could get into critical section.
when 2 process competeing, 1 must win.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Bounded waiting.</p>
<p>the waiting time should be limited.
1 process would lose,lose,lose&hellip;win!</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>software</p>
<p>rely on algorithms ensuring only 1 process in critical section.
since CS is untouchable, use entry and exit section to build the system.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Peterson&rsquo;s Solution</p>
<p>by Gary L. Peterson in 1981
between 2 process P0 and P1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> turn; <span style="color:#75715e">//whose turn it is to enter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>boolean flag[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">//init to FALSE. flag[i] = TRUE -&gt; Pi is ready.
</span></span></span></code></pre></div><!-- raw HTML omitted -->
<ul>
<li>
<p>Peterson&rsquo;s Algorithm</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//entry section start
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  flag[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> true; <span style="color:#75715e">//P0 ready
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//give away turn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (flag[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">&amp;&amp;</span>turn<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//wait while P1 is ready and having its turn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  critical_section();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//entry section end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  flag[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> false; <span style="color:#75715e">//exit section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//remainder section.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> } <span style="color:#66d9ef">while</span> (true);
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>cons</p>
<ul>
<li>complicated to program</li>
<li>busy waiting(CPU wasted)</li>
<li>it&rsquo;s better to just block the waiting process.
but that involves OS</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>hardware</p>
<p>rely on machine instruction of <a href="#locks">Locks</a></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Locks</p>
<p>lock on the required resource at <a href="#entry-section">entry section</a>
remove lock at <a href="#exit-section">exit section</a></p>
<!-- raw HTML omitted -->
<ul>
<li>Test and Set solution</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>compare and swap</p>
<p>the Pi finds lock = 0 proceed.
Pi lock other proc by setting lock = 1.
at exit, Pi set lock = 0 to enable progress.</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>pro</p>
<ul>
<li>scalable.
work on n proc. on n cores.</li>
<li>simple</li>
<li>multipel CS supported</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>con</p>
<!-- raw HTML omitted -->
<ul>
<li>busy-waiting</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>starvation</p>
<p>infinite blocking
1 proc leave CS, multiple waiting.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>deadlock</p>
<p>iofinite waiting to a signal from the other.
priority. High priority will obtain processor, while the current proc. don&rsquo;t have one to exit CS</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>OS and PL solution</p>
<p>provide function/stucture to use for synchronization</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Mutex lock/Mutual Exclusion</p>
<p>apply lock at entry, remove lock at exit.
block proc. asking for lock while the lock is unavailable</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>kernel-level</p>
<p>disable interupts</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>software-level</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>busy waiting(spinning)</p>
<p>constantly check if a lock is available.</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>spinlock</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Semaphores</p>
<p>Semaphore is a Integer var, that is only accessed by wait() and signal().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>wait(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(signal<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  signal<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>siganl(){
</span></span><span style="display:flex;"><span>  signal<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>by init signal to n, enable n processes into CS at same time.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>counting semaphore</p>
<p>semaphore goes to n
for resource having multiple instances</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>binary semaphore</p>
<p>semaphore init to 1</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>issue with semaphore</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="atomic-instuction">atomic instuction</h4>
<p>instruction that is not interuptable.</p>
<h4 id="preemptive-nonpreemptive-kernel">Preemptive/nonpreemptive kernel</h4>
<h4 id="multiprogramming">multiprogramming</h4>
<h4 id="synchronization-hardware">Synchronization hardware</h4>
<h4 id="race-condition">Race condition</h4>
<p>the condition that multiple proc.s manipulate same shared data concurrently.
final value depends on the random order of the manipulation.</p>
<p>To prevent race condition, concurrent processes must be synchronized</p>
<h4 id="classical-process-synchronization-probelms">classical process-synchronization probelms</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>The Bounded-Buffer / Producer-Consumer Problem</p>
<figure><img src="/ox-hugo/boundedbuffer.png"/>
</figure>

</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>The ReadersWriters Problem</p>
<p>n readers, n writers.
readers read, writers write.
write: only 1 writer access the shared data.
read: all reader and non writer can access the shared data
use a reader-writer lock that specify the mode of lock.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>The Dining-Philosophers Problem</p>
<figure><img src="/ox-hugo/diningphilosopher.png"/>
</figure>

<!-- raw HTML omitted -->
<ul>
<li>
<p>solutions</p>
<ul>
<li>allow only 4 philosopher to be hungary together</li>
<li>allow pickup only if both chopsticks available(in CS)</li>
<li>odd # philosophers pick left chopstick 1st</li>
<li>Even # philosopher always picks up right chopstick 1st</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="monitor">Monitor</h4>
<h3 id="cpu-scheduling">CPU Scheduling</h3>
<h4 id="concepts">concepts</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Execution phases of a process</p>
<p>interleaved with <code>cpu-burst</code> and <code>io-burst</code></p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>CPU-I/O Burst Cycle</p>
<p>each process is build up with interleaved cpu-burst and io-burst.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Type of I/O Processes</p>
<p>whether the process is I/O bound or CPU bound determined the apropriate scheduling algorithm</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>I/O bound</p>
<p>many short cpu burst
mostly waiting for I/O
affect user interaction.(word processor/emacs)</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>CPU Bound</p>
<p>few long cpu burst
I/O very few
long cpu burst helps
could do with lower priority(3d rendering, machine learning)</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Preemptive/non-preemptive Scheduling</p>
<ul>
<li>preemptive: the OS can stop execution of the running process on cpu</li>
<li>non-preemptive: the OS can&rsquo;t stop the current process. Must wait until it exit.</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>CPU Schedulers</p>
<ul>
<li>Trigger:
<ul>
<li>timer interrupt</li>
<li>running process blocked by I/O</li>
<li>By means of state change:
<ul>
<li>Running to Ready [interrupt] <code>preemptive</code></li>
<li>Running to Waiting [I/O request/wait()] <code>non-preemptive</code></li>
<li>Waiting to Ready [I/O complete] <code>preemptive</code></li>
<li>* to Terminate <code>non-preemptive</code></li>
</ul>
</li>
</ul>
</li>
<li>deed:
<ol>
<li>triggered</li>
<li>pick another process from ready queue</li>
<li>perform context switch</li>
</ol>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Dispatcher</p>
<p>hand in control of CPU to the selected process(by short-term scheduler)
called in every process switch</p>
<ol>
<li>switch context</li>
<li>switch to user-mode</li>
<li>jump to the execution location in the program</li>
</ol>
<!-- raw HTML omitted -->
<ul>
<li>
<p>dispatch latency</p>
<p>time of dispatcher stop and start process.</p>
</li>
</ul>
</li>
</ul>
<h4 id="criteria">criteria</h4>
<ul>
<li>Max CPU utilization  keep the CPU as busy as possible</li>
<li>Max Throughput  complete as many processes as possible per unit time</li>
<li>Fairness - give each process a fair share of CPU</li>
<li>Min Waiting time  process should not wait long in the ready queue</li>
<li>Min Response time  CPU should respond immediately</li>
</ul>
<h4 id="algorithms">algorithms</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Terms</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Arrive Time</p>
<p>point of process arrives in the <!-- raw HTML omitted -->ready queue<!-- raw HTML omitted --></p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Completion Time</p>
<p>point of process complete execution</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Burst time</p>
<p>duration required by a process for CPU execution</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Turnaround time</p>
<p>duration of | 1st time into ready state -&hellip;-&gt; complete |
turnaround time = Completion time - Arrive time</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Waiting Time</p>
<p>duration of process waiting in ready queue
Waiting Time = Turnaround Time - Burst Time</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Response Time</p>
<p>Point of process gets CPU for the 1st time</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Algors</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>First-Come, First-Served (FCFS) Scheduling</p>
<ul>
<li>first-come, first-served</li>
<li>waiting time high</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Shortest-Job-First (SJF) Scheduling</p>
<p>without preemption
aims at <code>shortest burst time</code></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>estimate next burst time</p>
<p>e = estimated time
t = actual time
a = weight factor (1 &lt; a &lt; 0)</p>
<p>\(e_{n+1} = at_n +(1-a)e_{n}\)</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>pro</p>
<ul>
<li>min average waiting time</li>
<li>min average response time</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>con</p>
<ul>
<li>not practical: burst time unknown
so SJF cannont be implemented at short term scheduling level</li>
<li>starve long job.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Shortest Remaining Time First (SRTF) Scheduling</p>
<ul>
<li>When the new-comer have the shortest burst time, switch to him.</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Priority Scheduling</p>
<ul>
<li>Each process assigned a priority
<ul>
<li>based on:
<ul>
<li>OS criteria(memory&hellip;)</li>
<li>admin&rsquo;s choice</li>
</ul>
</li>
</ul>
</li>
<li>cpu allocated to highest priority</li>
<li>Probelm:
<ul>
<li>Starvation: low priority never exec.
<ul>
<li>solution: aging.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Round Robin(RR) Scheduling</p>
<ul>
<li>a quantom of time <code>q</code> for everyone
q of P1, then q of P2&hellip;.</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Performance</p>
<ul>
<li>large q: FCFS</li>
<li>small q: cost of overhead. Large compared with context switch.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Multiple-Level Queues Scheduling</p>
<ul>
<li>Ready queue partitioned (permanantly) into 2 queues:
<ul>
<li>Foreground Proc</li>
<li>Background Proc</li>
</ul>
</li>
<li>Schedule in 2 types:
<ul>
<li>To the Queues</li>
<li>In the Queue</li>
</ul>
</li>
<li>Among the Queues:
<ul>
<li>Fixed Priority Scheduling
first forground, then backgound</li>
<li>Time slice
80% time Forground in RR, 20% time Background in FCFS</li>
</ul>
</li>
<li>Categories of Proc: in them the priority desc
<ul>
<li>Interactive processes</li>
<li>Non-interactive processes</li>
<li>CPU-bound processes</li>
<li>I/O-bound processes</li>
<li>Background processes</li>
<li>Foreground processes</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Multilevel Feedback Queue Scheduling</p>
<p>place process into priority queues based on their CPU burst behaviour</p>
<ul>
<li>IO higher, CPU lower</li>
<li>Basic Rules:
<ol>
<li>New proc. highest priority</li>
<li>quantum finished: (if proc not finish) into next lower queuef</li>
</ol>
</li>
<li>Parameters
<ul>
<li>n queues</li>
<li>scheduling algorithem for each queue</li>
<li>upgrade method</li>
<li>demote method</li>
<li>queue select method</li>
</ul>
</li>
<li>Example
<ul>
<li>Q1: RR 8ms</li>
<li>Q2: RR 16ms</li>
<li>Q3: FCFS</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Thread Scheduling</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>contention scope</p>
<p>the scope where the user threads compete for use of physical CPU</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Process Contention Scope PCS (unbound thread)</p>
<p>local.
many-to-one</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>System Contention Scope SCS (bound thread)</p>
<p>global
one-to-one</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Multiple-Processor Scheduling</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>inside Multiprocessor OS</p>
<ul>
<li>Require different inter-proc. comminucation &amp; synchronization techniques</li>
<li>All processors share a memory</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    &lt;!--list-separator--&gt;

    -  3 structures

        &lt;!--list-separator--&gt;

        -  Separate Kernel Configuration

            every Processor have it's own I/O device and file system
            little interdependency

            -   no parrallel execution

        &lt;!--list-separator--&gt;

        -  MasterSlave Configuration (Asymmetric Configuration)

             1 master processor and other slave processors
            OS run by master
            process scheduling run by master

        &lt;!--list-separator--&gt;

        -  Symmetric Configuration

            Any processor can access any device and can handle any interrupts generated on it.

            Mutual Exclusion for the OS is required.
            OS is seperated into independent parts. to prevent concurrency

            &lt;!--list-separator--&gt;

            -  approaches

                &lt;!--list-separator--&gt;

                -  common ready queue

                &lt;!--list-separator--&gt;

                -  per-core run queues

            &lt;!--list-separator--&gt;

            -  Process Affinity

                caches make 1 processor more &quot;familier&quot; for a process.
                So it's better to use 1 processor all along.

                &lt;!--list-separator--&gt;

                -  soft affinity

                    no guarentee

                &lt;!--list-separator--&gt;

                -  hard affinity

                    allowing a

            &lt;!--list-separator--&gt;

            -  Load Balencing

                for each core's queue

                &lt;!--list-separator--&gt;

                -  Push migration

                    when too long, push task to other processor's queue

                &lt;!--list-separator--&gt;

                -  Pull migration

                    when empty ready queue, read from othre processors' queue. Transfer them into my own queue

            &lt;!--list-separator--&gt;

            -  Multicore Processors

                a core executes a thread a time

                &lt;!--list-separator--&gt;

                -  Memory stall

                    single-core processor waiting for the data to become available.

                    use that time to execute other thread.

            &lt;!--list-separator--&gt;

            -  Hyperthreading

                a intel technology
                a physical processor divieded into 2 logical processors that are treated like seperate physical processors.

            &lt;!--list-separator--&gt;

            -  Multithreading

                multiple thread on same core

                &lt;!--list-separator--&gt;

                -  coarse-grained

                    switch thread only when 1 thread block

                &lt;!--list-separator--&gt;

                -  fine-grained

                    scheduling in Round Robin policy

&lt;!--list-separator--&gt;

-  Real-Time CPU Scheduling

    &lt;!--list-separator--&gt;

    -  Real-time system

        a system where time play important role

        &lt;!--list-separator--&gt;

        -  hard real-time system

            must meet deadline

        &lt;!--list-separator--&gt;

        -  soft real-time system

            desirable not not necesary

            &lt;!--list-separator--&gt;

            -  aperiodic tasks

                irregular arrival time

            &lt;!--list-separator--&gt;

            -  periodic tasks

                once per period T

    &lt;!--list-separator--&gt;

    -  Scheduling real-time tasks

        <figure><img src="/ox-hugo/realtimelatency.png"/>
</figure>


        &lt;!--list-separator--&gt;

        -  interrupt latency

            determine interrupt type
            switch context

        &lt;!--list-separator--&gt;

        -  dispatch latency

    &lt;!--list-separator--&gt;

    -  Static Scheduling

        schedule prepared before app startup

    &lt;!--list-separator--&gt;

    -  Priority-based scheduling

        priority assigned base on how quickly it must react

    &lt;!--list-separator--&gt;

    -  Dynamic scheduling

        schedule change over time.

    &lt;!--list-separator--&gt;

    -  timing constraints

        -   period:
        -   deadline:
        -

    &lt;!--list-separator--&gt;

    -  scheduling criteria

        -   timing constraints met
        -   cost of context switch, while preempting, must be reduced
        -

    &lt;!--list-separator--&gt;

    -  preemptively/non-preemptively, staticly/dynamically

    &lt;!--list-separator--&gt;

    -  Rate-Monotonic Scheduling

        static priority-based preemptive scheduling algorithm

        shortest period = highest priority

    &lt;!--list-separator--&gt;

    -  Earlies-Deadline-First Scheduling

        deadline - priority
        dynamically assign priority according to deadline

    &lt;!--list-separator--&gt;

    -  Proportional Share Scheduling

        T shares are allocated to all procs. in the system
        An app recive N shares. N &amp;lt; T

    &lt;!--list-separator--&gt;

    -  Process in here

        periodic.

        -   once the process get CPU, it has:
            -   fixed processing time \\(t\\)
            -   deadline \\(d\\)
            -   period \\(p\\)
            -   \\(0 \le t \le d \le p\\)
            -   rate \\(\frac{1}{p}\\)
            -   illustrate

                <figure><img src="/ox-hugo/ptd.png"/>
</figure>


&lt;!--list-separator--&gt;

-  Algorithm Evaluation

    

    &lt;!--list-separator--&gt;

    -  Deterministic evaluation

        1.  define workload: avg waiting time?
        2.  test.

    &lt;!--list-separator--&gt;

    -  Queueing Models

        we define queues for I/O and CPU, then queueing theory comes in handy

        &lt;!--list-separator--&gt;

        -  little's formula

            \\(n = \lambda \times W\\)
            n:average queue length
            W:avg waiting time
            \\(\lambda\\):avg arrival rate
            if we know 2 of the parameters, we know the thirs

    &lt;!--list-separator--&gt;

    -  Simulations

        trace tapes to provide real machine process to simulate algorithms on.
</code></pre>
<h3 id="deadlock">Deadlock</h3>
<h4 id="system-model">System Model</h4>
<ul>
<li>system have resources.</li>
<li>Resource have R types</li>
<li>Resource have W Instances</li>
<li>Process Use Resource with:
<ul>
<li>request</li>
<li>use</li>
<li>release</li>
</ul>
</li>
</ul>
<h4 id="deadlock-characterizaiton">Deadlock Characterizaiton</h4>
<p>deadlock arise if the four condition the same time</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Mutual exclusion</p>
<p>1 process at a time hold that resource</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Hold and wait</p>
<p>the process holding 1 resource wait for the other one</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>No preemption</p>
<p>resource released only voluntarily</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Circular wait</p>
<p>closed chain of process waiting for resource from the next one in chain</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Resource allocation Graph</p>
<figure><img src="/ox-hugo/resourceallocationgraph.png"/>
</figure>

</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Basic Facts</p>
<ul>
<li>graph have no cycle = no deadclock</li>
<li>have cycle:
<ul>
<li>1 instance per resource type = deadclock</li>
<li>n instances per resource type: possibilities.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="methods-for-handling-deadlocks">Methods for handling Deadlocks</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Deadlock Prevention</p>
<p>try to eliminate 1 of the 4 conditions</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Mutual exclusion</p>
<p>no</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Hold and wait</p>
<p>limit max resource hold to 1.
-&gt; low resource use,</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>No preemption</p>
<ul>
<li>when holding 1 asking 1 denyed, release all.</li>
<li>or if the asked 1 is held by other, preempt him</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Circular wait</p>
<p>order the resource types.
restrict request object to R3-5 after holding R3.</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Deadlock Avoidence</p>
<p>constrain request to prevent least 1 of the 4 conditions.</p>
<ul>
<li>don&rsquo;t start dangerous proc.</li>
<li>don&rsquo;t grant dangerous request.</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>safe state</p>
<p>at least 1 sequence of resource allocation that does not result in deadlock</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Max need</p>
<p>total amount of each resources</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>available resource</p>
<p>total amount of each unallocated resources</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>need</p>
<p>future request from P1 for R2</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>allocation</p>
<p>the R0 and R1 that P1 have been holding.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>single instance of Resource</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>claim edge</p>
<p>Pi may request Rj.
if check cycle, reject, otherwise claim -&gt; request</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Multiple Instances of REsources</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p><code>Banker's algorithm</code></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Data structures</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>n <span style="color:#f92672">=</span> number of process;
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> number of resource type;
</span></span><span style="display:flex;"><span>avalable[m] containing instance numbers;
</span></span><span style="display:flex;"><span>Max[n,m]. Max[i,j]<span style="color:#f92672">=</span>k,then Pi may request at most k instances of Rj;
</span></span><span style="display:flex;"><span>Allocation[n,m];Pi have k of Rjs;
</span></span><span style="display:flex;"><span>Need[n,m];Pi still need k of Rjs. Need[i,j] <span style="color:#f92672">=</span> Max[i,j]<span style="color:#f92672">-</span>Allocaiton[i,j]
</span></span></code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Safety Test algo</p>
<ol>
<li>
<p>init</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Work[m] <span style="color:#f92672">=</span> available[m];
</span></span><span style="display:flex;"><span>Finish[n]<span style="color:#f92672">=</span> false;
</span></span></code></pre></div></li>
<li>
<p>find <code>i</code> such that:</p>
<ul>
<li>Finish[i] = false</li>
<li>Need[i]&lt;=Work[i]</li>
<li>if no, goto step 4</li>
</ul>
</li>
<li>
<p>work = work + allocation; finish[i]= true;goto step 2</p>
</li>
<li>
<p>if finish[i] = true for all i, then safe state.</p>
</li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Resource request algo</p>
<p>pretend to do the request.
check that map.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Deadlock Detection</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Detection of single instance of resource</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>wait-for graph</p>
<p>merge resource.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>detection</p>
<p>search for loop in wait-for graph. O(n2)</p>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Detection for multiple instances of resources</p>
<p>banker&rsquo;s algorithm.</p>
<!-- raw HTML omitted -->
<ul>
<li>available</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>allocation</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>request</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Usage</p>
<p>when?
if too late, the deadlock would grow large and hard to deal with</p>
</li>
</ul>
</li>
</ul>
<h4 id="recovery-from-deadlock">Recovery from deadlock</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Process Termination / Abort Process</p>
<p> Abort all deadlocked processes
 Abort one process at a time until the deadlock cycle is eliminated</p>
<ul>
<li>Order</li>
<li>Priority of the process
<ol>
<li>How long process has computed, and how much longer to completion</li>
<li>Resources the process has used</li>
<li>Resource&rsquo;s process needs to complete</li>
<li>How many processes will need to be terminated</li>
<li>Is process interactive or batch?</li>
</ol>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Resource Preemption</p>
<ol>
<li>select victim</li>
<li>rollback</li>
<li>starvation
make sure limited time 1 is a victim</li>
</ol>
</li>
</ul>
<h2 id="the-project">The Project</h2>
<h3 id="scheduler">Scheduler</h3>
<p>My goal is to:</p>
<ol>
<li>Gain practical experiance of OS</li>
<li>Pass <a href="/braindump/errors/">CPT104 OS Concepts</a> with High score</li>
</ol>
<p>In order to do that, not only I should complete all CPT104 Activities, but also dig in using</p>
<ul>
<li>MIT6.S081
I stored thing in my download drive
<a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">official schedule</a> holds schedule information of the course.</li>
<li>the Dinosaur book
it contains much practical problems.</li>
</ul>
<p>The MIT course is in video and practices, and the dinosour book is a book. I plan to use <a href="#page-reading-machine">page reading machine</a> on <a href="#the-dinosaur-book">the Dinosaur book</a> and <a href="#video-watching-machine">video watching machine</a> on the video materails of MIT.</p>
<p>I&rsquo;ll be holding Notes in this page, which, will be transformed into blogs in the future on my website.</p>
<p>Keep that in mind, and knows that there&rsquo;s an audiance. So make them comprehensible, and complete.</p>
<h3 id="page-reading-machine">page reading machine</h3>
<h4 id="principle">Principle</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Distributed Exposure</p>
<p>Various exposure to the materials build familiarance, the key to memory and understanding/processing.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Initiative</p>
<p>Taking Initiative counters dizziness and copying.</p>
</li>
</ul>
<h4 id="flow">Flow</h4>
<ol>
<li>Go through the headings, mark seemed important keywords to headings</li>
<li>after the first skim, go to the notes and try to explain them. When failed, check the text.</li>
<li><code>[[]]</code> juicy jargons along the way</li>
<li>after current node done&hellip;</li>
<li>navigate to the first link(<code>C-c C-x C-p</code>)</li>
<li>Create and edit the node</li>
<li>Refile it to where it belong(<code>C-c m</code>)</li>
<li>Back to the point using <code>org-mark-ring-goto(C-c 5)</code></li>
<li>Go to next link(<code>C-c C-x C-n</code>)</li>
<li>Repeat step 4-7 until all links are pointing to somewhere.</li>
</ol>
<h3 id="video-watching-machine">video watching machine</h3>
<h4 id="constructing-video-watching-machine"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Constructing video watching machine</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p><!-- raw HTML omitted -->TODO<!-- raw HTML omitted -->  Do a class conventionally, record obstacles.</p>
<p>Goal - Problem record - Diagnose - Plan - Execution.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>conventianl watching</p>
<ol>
<li>Watch video</li>
<li>(Pause video to)Take note of every section</li>
<li>Take note of every listed experiance</li>
<li>Take note of every code.</li>
<li>Try the code myself.</li>
</ol>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Note</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Page table</p>
<p>a.k.a, virtual memory.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>why use Page table? =&gt; Isolation.</p>
<p>To implement <code>isolation between programs</code> in a <code>whole bulk of physical memory space</code>.</p>
<p><a href="#address-space">Address space</a> is the idea of an ideal Isolated Senario.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Address Space</p>
<p>Give every process it&rsquo;s own <code>Address space</code></p>
<p><code>illustrate of 3 process having there own address space</code></p>
<p>There are various approaches to implement Address space. <a href="#page-table">Page Table</a> is one approach.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Pageing Hardware</p>
<p>The hardware structure that supports <a href="#page-table">Page Table</a>, mainly by processor, or MMU</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Page Table</p>
<p><code>Illustrate of paging</code></p>
<ul>
<li>VA: Virtual Address, PA: Physical Address
<ul>
<li>VA: location of the code from the process&rsquo;s perspective</li>
<li>PA: location of the code from main memory&rsquo;s perspective</li>
</ul>
</li>
<li>CPU holds:
<ul>
<li>satp register: PA, location of page table in main memory.</li>
<li>other: VA, location of data or code address.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>xv6 vm code+layout</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="practice">Practice</h3>
<p>The MIT course provides extensive lab practices.
The completion and logging would be stored in <a href="#mit-6-dot-s081-lab-logs">MIT 6.S081 Lab Logs</a></p>
<h2 id="mit-6-dot-s081-lab-logs">MIT 6.S081 Lab Logs</h2>
<h3 id="lab-1-unix-utils">Lab 1: Unix utils</h3>
<h4 id="reading-xv6-ch1"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> reading xv6 ch1</h4>
<h4 id="xv6-system-calls">xv6 system calls</h4>
<table>
<thead>
<tr>
<th>System call</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int fork()</td>
<td>Create a process, return childs PID.</td>
</tr>
<tr>
<td>int exit(int status)</td>
<td>Terminate the current process; status reported to wait(). No return.</td>
</tr>
<tr>
<td>int wait(int *status)</td>
<td>Wait for a child to exit; exit status in *status; returns child PID.</td>
</tr>
<tr>
<td>int kill(int pid)</td>
<td>Terminate process PID. Returns 0, or -1 for error.</td>
</tr>
<tr>
<td>int getpid()</td>
<td>Return the current processs PID.</td>
</tr>
<tr>
<td>int sleep(int n)</td>
<td>Pause for n clock ticks.</td>
</tr>
<tr>
<td>int exec(char *file, char *argv[])</td>
<td>Load a file and execute it with arguments; only returns if error.</td>
</tr>
<tr>
<td>char *sbrk(int n)</td>
<td>Grow processs memory by n bytes. Returns start of new memory.</td>
</tr>
<tr>
<td>int open(char *file, int flags)</td>
<td>Open a file; flags indicate read/write; returns an fd (file descriptor).</td>
</tr>
<tr>
<td>int write(int fd, char *buf, int n)</td>
<td>Write n bytes from buf to file descriptor fd; returns n.</td>
</tr>
<tr>
<td>int read(int fd, char *buf, int n)</td>
<td>Read n bytes into buf; returns number read; or 0 if end of file.</td>
</tr>
<tr>
<td>int close(int fd)</td>
<td>Release open file fd.</td>
</tr>
<tr>
<td>int dup(int fd)</td>
<td>Return a new file descriptor referring to the same file as fd.</td>
</tr>
<tr>
<td>int pipe(int p[])</td>
<td>Create a pipe, put read/write file descriptors in p[0] and p[1].</td>
</tr>
<tr>
<td>int chdir(char *dir)</td>
<td>Change the current directory.</td>
</tr>
<tr>
<td>int mkdir(char *dir)</td>
<td>Create a new directory.</td>
</tr>
<tr>
<td>int mknod(char *file, int, int)</td>
<td>Create a device file.</td>
</tr>
<tr>
<td>int fstat(int fd, struct stat *st)</td>
<td>Place info about an open file into *st.</td>
</tr>
</tbody>
</table>
<p>cci| int stat(char *file, struct stat *st) | Place info about a named file into *st.                                  |</p>
<table>
<thead>
<tr>
<th>int link(char *file1, char *file2)</th>
<th>Create another name (file2) for the file file1.</th>
</tr>
</thead>
<tbody>
<tr>
<td>int unlink(char *file)</td>
<td>Remove a file.</td>
</tr>
</tbody>
</table>
<h4 id="fork">fork()</h4>
<p>create a child process</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>positions</p>
<ul>
<li>memory: same content, different location</li>
<li>file descriptors: the same</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>behaviour</p>
<ul>
<li>a child process created, with identical everything of the parent process.</li>
<li>child process and parent process don&rsquo;t share memory variables</li>
<li>[?] whereever the <code>fork()</code> call is at, the whole program is duplicated</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>returns</p>
<ul>
<li>pid of the created child [in parent]</li>
<li>0 [in child]</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Tree of child processes</p>
<ul>
<li>Since
<ul>
<li>in child processes, the value of the creating fork() is 0</li>
<li>memory is duplicated for every child.</li>
</ul>
</li>
<li>Therefore
<ul>
<li>on a leaf child
if use <code>pid1=fork()</code> to store the pid, then all processes in the route from root to this child would have pid stored 0.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="wait">wait()</h4>
<p>wait() is companion of <a href="#fork">fork()</a>, parent block until childs finish.</p>
<h4 id="exit">exit()</h4>
<h4 id="file-descriptor">File Descriptor</h4>
<p>it&rsquo;s an integer.
like, 0 - standard in, 1 - standard out, 2 - standard error</p>
<h4 id="read">read()</h4>
<h4 id="write">write()</h4>
<h4 id="file-system">File system</h4>
<h4 id="pipe">Pipe</h4>
<ul>
<li>1 pipe for one way communication.</li>
<li>the file</li>
</ul>
<h4 id="lab1-dot-2-sleep">lab1.2: sleep()</h4>
<p>I see that you need 1 pipe for each direction of communication, 1 for P1 to P2, and 1 for P2 to P1
Otherwise, when P1 finished writing and start to read, it could read the data it just write into the pipe.</p>
<h4 id="lab1-dot-3-prime">lab1.3: prime()</h4>
<ul>
<li>I see that procedure doing it is not promising: no</li>
<li>I see that funciton layer_init don&rsquo;t work well. it don&rsquo;t tell whether the nums are prime.</li>
<li>It&rsquo;s key where the child is inited in the recursive calls.
it should be not in the while loop for while loop is giving it chance to</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;../kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;../kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> p1[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  pipe(p1);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fork() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>      write(p1[<span style="color:#ae81ff">1</span>],<span style="color:#f92672">&amp;</span>i,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;inited %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    child_process(p1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">child_process</span>(<span style="color:#66d9ef">int</span> p[<span style="color:#ae81ff">2</span>]){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> prime;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> child_p[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  pipe(child_p);
</span></span><span style="display:flex;"><span>  close(p[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> read(p[<span style="color:#ae81ff">0</span>],<span style="color:#f92672">&amp;</span>prime,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;prime: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,prime);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (len<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){close(p[<span style="color:#ae81ff">0</span>]);exit(<span style="color:#ae81ff">0</span>);}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fork()<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>    close(p[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    child_process(child_p);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> read(p[<span style="color:#ae81ff">0</span>],<span style="color:#f92672">&amp;</span>num,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (len<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){close(p[<span style="color:#ae81ff">0</span>]);close(child_p[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>	wait(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	exit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( num <span style="color:#f92672">%</span> prime<span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>	write(child_p[<span style="color:#ae81ff">1</span>],<span style="color:#f92672">&amp;</span>num,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<ul>
<li>
<p>good recursive concurrent process call sturcure</p>
<ol>
<li>every child process have it&rsquo;s own setup -&gt; child_process()</li>
<li>fork(), and on the child process, invoke child_process()</li>
</ol>
<p>Then, the structure would be a lovely:</p>
<figure><img src="/ox-hugo/recurrent.png" width="400px"/>
</figure>

</li>
</ul>
<h4 id="miscellaneous">miscellaneous</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>main(int argc, char* argv[])</p>
<ul>
<li>argc: count of args passed by command-line</li>
<li>argv: args.
typically, for <code>echo hi!</code>, <code>argv[0] = &quot;echo&quot;, argv[1] = &quot;hi!&quot;</code></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>how to add program?</p>
<ol>
<li>write source code</li>
<li>add path to <code>UPROC</code> variable in <code>riscv-2019fall/Makefile</code></li>
<li>recompile with <code>make qemu</code> and the program should be loaded to the shell</li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>in usys.S</p>
<p>what <code>li</code> means in <code>li a7, SYS_sleep</code>?</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>loading sleep</p>
<p>write the code into user/sleep.c, and the Make would take care of later things.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>page fault!</p>
<pre tabindex="0"><code class="language-example" data-lang="example">init: starting sh
$ sleep
sleep
wrong number of args!usertrap(): unexpected scause 0x000000000000000f (store/AMO page fault) pid=3
	    sepc=0x00000000000000fe stval=0x0000000000003038
</code></pre><!-- raw HTML omitted -->
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>how large is 1 byte?</p>
<p>a int? a char?</p>
</li>
</ul>
<h2 id="address-space">Address space</h2>

      </div>
      


   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   




      </div>
   </div>
</div>

<script src="https://hermanhel.github.io/braindump/js/URI.js" type="text/javascript"></script>

<script src="https://hermanhel.github.io/braindump/js/page.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
