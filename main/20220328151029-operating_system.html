<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>20220328151029-operating_system.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

[WARNING] Duplicate identifier 'scheduling' at line 527 column 1
[WARNING] Duplicate identifier 'thread' at line 852 column 1
[WARNING] Duplicate identifier 'thread' at line 854 column 1
[WARNING] Duplicate identifier 'multithreading-models' at line 1007 column 1
[WARNING] Duplicate identifier 'thread-libraries' at line 1038 column 1
[WARNING] Duplicate identifier 'process-synchronization' at line 1254 column 1
[WARNING] Duplicate identifier 'cpu-scheduling' at line 1551 column 1
[WARNING] Duplicate identifier 'fork' at line 2558 column 1
<p>+++ title = “Operating System” author = [“Linfeng He”] draft = false +++</p>
<p>The Info comes most from MITOCW</p>
<h2 id="mit-6-dot-s081">MIT 6.S081</h2>
<h3 id="meta">meta</h3>
<p>6.s081. a website. qemu, a hardware simulation under linux xv6, a teaching OS, on RISC-V processor</p>
<h3 id="overview">Overview</h3>
<h4 id="what-operating-system-do">What Operating system do</h4>
<ul>
<li>Abstract Hardware</li>
<li>Multiplex</li>
<li>Isolation</li>
<li>Sharing</li>
<li>Security access</li>
<li>Preformance</li>
<li>Range of application</li>
</ul>
<h4 id="orgnization-image">orgnization Image</h4>
<p><img src="/ox-hugo/os1.png" /> Kernel have filesystem, process management, memory management…codes.</p>
<ul>
<li>filesystem: give more high-level way to name files, orgnize directories,etc.</li>
<li>process management: vi, cc are like different processes, and we want then to run concurrently, without interfering each other.</li>
<li>memory: and we divide and allocate memory to them.</li>
</ul>
<h4 id="api-kernel">API - kernel</h4>
<p><code>fd = open("path",1)</code> much like defining a funciton, but <code>system calls</code> jump into kernel and run kernel code. The kernel code have the special access to hardware and other kernel code user-defined function don’t have</p>
<h4 id="why-os-is-interesting">Why OS is interesting?</h4>
<!--list-separator-->
<ul>
<li>OS have it’s projection into all softwares</li>
</ul>
<!--list-separator-->
<ul>
<li><p>Tensions</p>
<p><!--list-separator--></p>
<ul>
<li>efficient - abstract</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>powerful - simple</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>flexible - secure</p>
<p>want the user code to as flexible as possible, but don’t want them to subatage other programs.</p></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>the interaction of funcitons OS provided</p>
<p>fork() create a new process that is a copy of the currrent one, then how will the resources this process accesed interact with this copy?</p></li>
</ul>
<!--list-separator-->
<ul>
<li>The infrastructures and services</li>
</ul>
<!--list-separator-->
<ul>
<li>Tracking bugs</li>
</ul>
<h4 id="example-of-system-call-what-it-looks-like">Example of system call - what it looks like?</h4>
<!--list-separator-->
<ul>
<li><p>Installing xv6</p>
<p><!--list-separator--></p>
<ul>
<li><ol type="1">
<li>installing i386 elf</li>
</ol>
with macport installed <code>sudo port install i386-elf-gcc</code></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Simple program</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;kernel/types.h&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;user/user.h&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> buf[<span class="dv">64</span>];</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n = read(<span class="dv">0</span>,buf,<span class="kw">sizeof</span>(buf)); <span class="co">//0 console input, 1 console output by shell.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//buf is a pointer to a memory address where the program ask the OS to read the data into. it&#39;s a reserved 64 cells on the stack.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//sizeof(buf) is the maximum read size.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(n&lt;=<span class="dv">0</span>) <span class="cf">break</span>;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    write(<span class="dv">1</span>,buf,n);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  exit(<span class="dv">0</span>);</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="src-block-caption">
<span class="src-block-number">Code Snippet 1</span>: copy.c
</div>
<p>chapter 2 of the xv6 book have a table of all system call args.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Fork()</p>
<p>it created 1 identical children process, return the pid of the process, and return 0 if used in the children process. The copy doesn’t start/stop corresponding to where the fork() system call is used, but the whole process, and the only difference of the 2 process, is the pid, and what fork() would return.</p>
<p>the memory’s the same. in different memory</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>exec()</p>
<p>replace the current process’s memory entirely, and never return. return only under error.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> *argv[] = {<span class="st">&quot;echo&quot;</span>,<span class="st">&quot;this&quot;</span>,<span class="st">&quot;is&quot;</span>,<span class="st">&quot;echo&quot;</span>,<span class="dv">0</span>}; <span class="co">//0 to signify the end of the array</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">//each &quot;sth&quot; is a pointer pointing to a address storing the bytes. 0 points to NULL. when pointer&#39;s value is 0, it&#39;s a NULL pointer.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  exec(<span class="st">&quot;echo&quot;</span>,argv);</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  printf(<span class="st">&quot;exec failed!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  exit(<span class="dv">0</span>);</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="src-block-caption">
<span class="src-block-number">Code Snippet 2</span>: exec.c
</div>
<p>shell use forkexac to execute a command on the fork() of it, and then regain control when the child process exited</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>redirection</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> pid;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  pid = fork();</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(pid == <span class="dv">0</span>){</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    close(<span class="dv">1</span>);</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    open(<span class="st">&quot;output.txt&quot;</span>, O_WRONLY | O_CREATE);</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> *arg[]={<span class="st">&quot;echo&quot;</span>,<span class="st">&quot;This&quot;</span>,<span class="st">&quot;is&quot;</span>,<span class="st">&quot;echo&quot;</span>,<span class="st">&quot;redirected&quot;</span>,<span class="dv">0</span>};</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    exec(<span class="st">&quot;echo&quot;</span>,argv);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;exxec failed&quot;</span>);</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    wait((<span class="dt">int</span> *) <span class="dv">0</span>);</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  exit(<span class="dv">0</span>);</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>after <code>close(1);</code>, file descriptor <code>1</code> is closed. <code>open("output.txt",)</code> will bind the lowest number of available file descriptor(1) to <code>output.txt</code></p></li>
</ul>
<h3 id="os-organization">OS organization</h3>
<h4 id="to-check">to check</h4>
<p>prime pipe: in fork, it will have 4 ends. concurent</p>
<h4 id="isolation">isolation</h4>
<p>strong isolation between OS and app. So OS won’t crash with error of app</p>
<!--list-separator-->
<ul>
<li><p>If there’s no OS?</p>
<p>no multiplexing. The dead loop will continue to run to the end of time so we want the app to give up cpu once in a while</p>
<p>also, with memory, the perculating of echo and shell. echo can’t overwrite shell’s physical memory</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>OS’s perpose</p>
<ul>
<li>enforce strong isolation</li>
<li>enforce multiplexing</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Unix Interface</p>
<p>Abstract the HW resource like process. process system calls act on the abstraction of process, not directly to CPU. So the kernel could allow multiplexing of CPU.</p>
<p>The kernel would force the idea that a process won’t be able to run for &gt;100ms. exec() is abstraction of memory. The file it works with act like a part of program working memory, which have no physical correspondance with a partucular location.</p>
<p>file() abstract disk blocks. You can’t directly read or write. The OS have its way to map the files to disk locations, and make sure the file in that block is unique system-wise. Other people can’t know/access it.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>OS should be defensive</p>
<ul>
<li>app can’t crash the OS</li>
<li>app can’t break the isolation</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>typical: HW support</p>
<p>to strong isolation.</p>
<p><!--list-separator--></p>
<ul>
<li><p>user/kernel mode</p>
<p><!--list-separator--></p>
<ul>
<li><p>user mode</p>
<p>only unpriveleged instructions <code>add</code> <code>sub</code></p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>kernel mode</p>
<p>priviledge of instructions. <code>manitulating hw directely</code> <code>setting up page table</code> <code>disable clock interupt</code></p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>page table/virtual memory</p>
<p><!--list-separator--></p>
<ul>
<li><p>page table</p>
<p>map virtual addr to physical addr vew on memory basic idea: give every process its own page table. so that the process don’t have knowledge of others physical memory strong memory isolation</p></li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Entering kernel</p>
<p>sometimes we want to transfer control to kernel in user app. <code>ecall(n)</code> n is a number of system call number enter kernel at a <code>entry point</code></p>
<p>fork() = ecall(n) n is the system call number of fork it goes in the kernel, in a file called syscall.c, in which it checked the number, and then call the function</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>trusted computing base (TCP)</p>
<ul>
<li>kernel have no bug</li>
<li>kernel treat software as malicious</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>kernel design</p>
<p><!--list-separator--></p>
<ul>
<li><p>monolithic kernel design</p>
<p>all OS code in kernel mode</p>
<ul>
<li>serious bug</li>
<li>tight integration - high performance</li>
<li>large more(historical reason)</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>microkernel design</p>
<ul>
<li>some in kernel mode
<ul>
<li>ipc</li>
<li>vm</li>
<li>multiplex</li>
</ul></li>
<li>bulk of OS run in user mode</li>
<li>fewer bugs</li>
<li>use msgs. Shell -msg- ipc -msg- FS -msg- ipc -msg- Shell</li>
<li>performance
<ul>
<li>jumping</li>
<li>tight integration</li>
</ul></li>
<li>embeded more</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Makefile of xv6</p>
<p>proc.h -gcc- proc.s -assembler- proc.o -ld- kernel (all the *.o files load together) a kernel.asm is gnerated to see the full form of kernel.</p>
<p>The qemu enulate a board of risc5 schema board. Should think it that way. It’s a c program of for loop</p></li>
</ul>
<h4 id="kernel-user-mode">kernel/user mode</h4>
<h4 id="system-call">system call</h4>
<h4 id="the-above-in-xv6">the above in xv6</h4>
<h3 id="page-tables--virtual-memory">Page Tables (virtual memory)</h3>
<h3 id="inbox">Inbox</h3>
<h4 id="hold-and-wait-condition">hold and wait condition</h4>
<p>to prevail</p>
<h4 id="mutual-exclusion">Mutual exclusion</h4>
<h4 id="scheduling">Scheduling</h4>
<!--list-separator-->
<ul>
<li>Round Robin Scheduling Algorithm</li>
</ul>
<h2 id="the-dinosaur-book">the Dinosaur book</h2>
<h3 id="introduction">Introduction</h3>
<h4 id="what-is-os">What is OS?</h4>
<!--list-separator-->
<ul>
<li><p>Kernel</p>
<p>a program runing all the time</p>
<ul>
<li>System programs part of OS but not in kernel</li>
<li>Middleware set of software framework provide additional servises graphic, database, multimedia</li>
</ul></li>
</ul>
<h4 id="computer-system-operation">Computer-System Operation</h4>
<!--list-separator-->
<ul>
<li><p>Bootstrap program(firmware)</p>
<ul>
<li>to start the computer</li>
<li>in ROM or EEPROM</li>
<li><code>locate OS Kernal and load it into Memory</code></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li>Kernel start</li>
</ul>
<!--list-separator-->
<ul>
<li><p>System process</p>
<ul>
<li>after kernel start, it would start some system processes(system daemons)</li>
<li>They run while kernel is runing</li>
<li>After this, the whole system is <code>booted</code>. The system then wait for <code>event to occur</code></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Interupt</p>
<ul>
<li>Interupt signal the <code>event</code></li>
<li>Trigered by:
<ul>
<li>hardware: sending signal to CPU</li>
<li>software: <code>system call</code> (monitor call)</li>
</ul></li>
<li>After interupted, CPU:
<ol type="1">
<li>Stop what it’s doing</li>
<li>Transfer execution to a fixed point</li>
</ol></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Interupt Vector</p>
<p>A table holding some commonly used interupt service for some devises</p></li>
</ul></li>
</ul>
<h3 id="operating-system-structure">Operating-System Structure</h3>
<h3 id="processes">Processes</h3>
<h4 id="process">Process</h4>
<p>Program in execution Program = xx.exe. Process = that thing in memory after you load xx.exe into memory</p>
<!--list-separator-->
<ul>
<li><p>Composition</p>
<p>{{&lt; figure src=“/ox-hugo/process.png” &gt;}}</p>
<ul>
<li>Text section: program code</li>
<li>Program counter: the current activity</li>
<li>Stack: temporary data(like funciton parameter.etc)</li>
<li>Data section: global vars</li>
<li>Heap: dynamically allocated memory</li>
</ul></li>
</ul>
<h4 id="states">States</h4>
<p>As the program executed, the states change. states: <code>new,ready,running,waiting,terminated</code></p>
<ul>
<li>new: the process is created</li>
<li>running: instructions are being executed</li>
<li>waiting: the process is waiting some event to occur like I/O or siganl</li>
<li>Ready: the process is waiting to be assigned to a processor</li>
<li>terminated: the process has finished execution</li>
</ul>
<p>{{&lt; figure src=“/ox-hugo/procstates.png” &gt;}}</p>
<h4 id="queues">Queues</h4>
<p>Queue is where process is put when not executing Dispatch: selected to exec</p>
<p>{{&lt; figure src=“/ox-hugo/queues.png” &gt;}}</p>
<!--list-separator-->
<ul>
<li>I/O request queue</li>
</ul>
<!--list-separator-->
<ul>
<li><p>Ready Queue</p>
<p>contains all processes ready to exec. Waiting for CPU Each Process is represented with <a href="#pcb">PCB</a> in Ready Queue Generally a <code>linked list</code></p>
<ul>
<li>header: contains pointer to 1st and final PCB.</li>
</ul>
<p>Each PCB have a field pointing to next PCB</p></li>
</ul>
<h4 id="pcb">PCB</h4>
<p>Process Control Block(task control block) is the representation of Process</p>
<p>{{&lt; figure src=“/ox-hugo/pcb.png” &gt;}}</p>
<ul>
<li>Process state as in <a href="#states">States</a></li>
<li>Program Counter: Address of next instruction to exec for this proc.</li>
<li>Registers: The condition of all registers of that CPU execing the Proc. When Interupt comes, Program Counter and Registers are stored, so that when it’s back on the table, they could continue.</li>
<li>CPU scheduling information:(more in <a href="#cpu-scheduling">CPU Scheduling</a>)
<ul>
<li>process priority</li>
<li>pointer to scheduling queues</li>
<li>other scheduling parameters</li>
</ul></li>
<li>Memory-Management information(more in <a href="#main-memory">Main Memory</a>) memory stuffs, like page table.</li>
<li>Accounting information
<ul>
<li>amount of CPU</li>
<li>real time used</li>
<li>time limit</li>
<li>account number</li>
<li>job/proc number</li>
<li>etc</li>
</ul></li>
<li>I/O status information
<ul>
<li>list of I/O devices allocated to the process</li>
<li>list of open files</li>
</ul></li>
</ul>
<h4 id="thread">Thread</h4>
<p>the <a href="#pcb">PCB</a> will be modified to include thread information to support multi thread system</p>
<h4 id="scheduling">Scheduling</h4>
<!--list-separator-->
<ul>
<li><p>Objectives</p>
<ul>
<li>multiprogramming: have something to run always</li>
<li>time-sharing: have everything running interactive</li>
</ul>
<p>to meet these objectves, the <code>process scheduler</code> select proc.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Long-term(job) scheduler</p>
<p>Process are stored on a disk when first submitted. Job scheduler select from that pool to load into memeory controls the <code>degree of multiprogramimg</code> (how many proc.s in memory)</p>
<p>selection of process that will be allowd to get in touchwith CPU Influenced by: <code>resource allocation consideration</code></p>
<p>sometimes absent, like in unix/ms.</p>
<p><!--list-separator--></p>
<ul>
<li><p>careful selection</p>
<ul>
<li>Bound:
<ul>
<li>I/O-bound: more time in I/O</li>
<li>CPU-bound: more time in computation</li>
</ul></li>
<li>a good process fix: both of them mixed nicely, so that no device is wasted.(no too long queue and empty queue)</li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Short-term(CPU)</p>
<p>select from ready processes to feed CPU Very frequent, least once every 100ms</p>
<p>selection of 1 process from CPU</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Medium-term scheduler</p>
<p>sometimes it’s good to swap a proc out. swapping(more in <a href="#main-memory">Main Memory</a>)</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Context Switch</p>
<p>include:</p>
<ul>
<li>CPU Registers</li>
<li>process state</li>
<li>memory-management information</li>
</ul>
<p>Few ms speed. putting the context in other place, and load the context in the new process’s PCB</p></li>
</ul>
<h4 id="operations-on-process">Operations on Process</h4>
<!--list-separator-->
<ul>
<li><p>Creation</p>
<p><code>Parent</code> proc. create <code>Child</code> proc. Forming a tree, starting from the proc with pid=0</p>
<p><!--list-separator--></p>
<ul>
<li><p>Resource Options</p>
<ul>
<li>share all resource</li>
<li>child use subset of parent’s resource</li>
<li>share no resource</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Execution Options</p>
<ul>
<li>concurrently</li>
<li>parent wait for child to terminate.</li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Termination</p>
<p>Process use <code>exit()</code> to ask OS to delete it. This:</p>
<ul>
<li>return status data from child to parent (0 for normal)</li>
<li>cause the resource to be relocated</li>
</ul>
<p>Parent use <code>wait()</code> to wait for child to finish</p></li>
</ul>
<h4 id="parent-child-process">Parent/Child process</h4>
<!--list-separator-->
<ul>
<li><p>execution</p>
<p>wait, or concurrently Concurrent is good forL <code>information sharing, computation speedup, modularity, and convenience</code></p></li>
</ul>
<h4 id="coorperating-process">Coorperating process</h4>
<!--list-separator-->
<ul>
<li><p>interprocess communication mechanism</p>
<p><!--list-separator--></p>
<ul>
<li><p>shared memory</p>
<p>share some variables</p>
<ul>
<li>type of buffer
<ul>
<li>bounded: fixed buffer size</li>
<li>unbounded: no limit on the size of buffer</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>how to do it?</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>message passing</p>
<p>{{&lt; figure src=“/ox-hugo/messagepassing.png” &gt;}}</p>
<p><!--list-separator--></p>
<ul>
<li><p>How?</p>
<p>a message passing facility provide:</p>
<ul>
<li>send(message)</li>
<li>receive(message)</li>
</ul>
<p>a communication link must exist between them</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Direct/indirect communication</p>
<p>Messages goes into a queue Buffering of the queue:</p>
<ul>
<li>Zero capacity</li>
<li>Bounded</li>
<li>unbounded</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Direct Communication</p>
<p>use <code>send(P,message)</code> and <code>recieve(Q,message)</code>. use pid for the communication (P,Q) hard to find the sender.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Indirect</p>
<ol type="1">
<li>Create a port A</li>
<li>use <code>send(A,message)</code>, <code>recieve(A,message)</code></li>
<li>destroy a port</li>
</ol></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Synchronous/asynchronous communication</p>
<p>Blocking is synchronous, non-blocking is asynchronous</p>
<ul>
<li>Blocking
<ul>
<li>send: sender is blocked until message recieved</li>
<li>recieve: reciever is blocked until recieve message</li>
</ul></li>
<li>non-blocking
<ul>
<li>send: send and go</li>
<li>recieve: recieve something or NULL</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>Automatic/explicit buffering</li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>communication in client-server systems</p>
<p><!--list-separator--></p>
<ul>
<li><p>socket</p>
<p>socket = endpoint of communication a connection between 2 applications include 2 sockets on each end of communication channel</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>remote procedure call(RPC)</p>
<p>1 process/thread call procedure on remote application</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>pipes</p>
<p>take output of a command as input of another</p></li>
</ul></li>
</ul>
<h3 id="threads">Threads</h3>
<p>Thread is a <code>stream of instruciton</code></p>
<ul>
<li>Benefits:
<ol type="1">
<li>less time to create/terminate/switch than proc.</li>
<li>better communication efficiency</li>
</ol></li>
<li>Representation: Thread Control block
<ul>
<li>Thread ID</li>
<li>Program counter: which instruciton next</li>
<li>Register set: current working variables</li>
<li>Stack: history of thread execution</li>
<li>other things it share with other threads in the proc.</li>
</ul></li>
</ul>
<h4 id="multicore-programming">Multicore Programming</h4>
<!--list-separator-->
<ul>
<li><p>Concurrency / Parallelism</p>
<ul>
<li>Concurrency: Overlaped executing period.</li>
<li>Parallelism: Multicore multitasking.</li>
</ul></li>
</ul>
<h4 id="multithreading-models">Multithreading Models</h4>
<!--list-separator-->
<ul>
<li><p>User level threading</p>
<p>some software library with threading util take care of that.</p>
<ul>
<li>Pro
<ul>
<li>No mode switiching -&gt; fast</li>
<li>cross-OS</li>
<li>flexible. We can write the scheduling algor. ourselves.</li>
</ul></li>
<li>Con
<ul>
<li>system calls block for process. All thread in the process will be blocked altogether.</li>
<li>only concurrecy, not parallelism. only 1 processor.</li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li>Kernel level threading</li>
</ul>
<!--list-separator-->
<ul>
<li><p>Many to One Model</p>
<p><code>Thread library</code> do the thread in user space</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>One-to-One model</p>
<p>Kernel knows. Each user thread map into 1 kernel thread</p></li>
</ul>
<h4 id="thread-libraries">Thread Libraries</h4>
<h4 id="implicit-threading">Implicit Threading</h4>
<h4 id="threading-issues-design-method">Threading issues/Design method</h4>
<h3 id="process-synchronization">Process Synchronization</h3>
<h3 id="cpu-scheduling">CPU Scheduling</h3>
<h3 id="deadlocks">Deadlocks</h3>
<h3 id="main-memory">Main Memory</h3>
<h3 id="virtual-memory">Virtual Memory</h3>
<h3 id="mass-storage-structure">Mass-Storage Structure</h3>
<h3 id="file-system-interface">File-System Interface</h3>
<h3 id="file-system-implement">File-System Implement</h3>
<h3 id="i-o-systems">I/O Systems</h3>
<h3 id="protection">Protection</h3>
<h3 id="security">Security</h3>
<h3 id="virtual-machines">Virtual Machines</h3>
<h3 id="distributed-systems">Distributed Systems</h3>
<h2 id="trying-machine">Trying Machine</h2>
<h3 id="thread">Thread</h3>
<h4 id="thread">Thread</h4>
<p>stream of instruciotn flow of control in a process</p>
<h4 id="pros-of-thread">Pros of Thread</h4>
<ul>
<li>Responsiveness have 1 thread doing a very difficult job other threads works normal, and interact immediately</li>
<li>Resource sharing thread of 1 process share the memories without explicit specification</li>
<li>Economy faster in creation and context switch due to resource sharing</li>
<li>Scalability can run faster on multicore systems. while 1 thread process runs the same on multicore or singlecore.</li>
</ul>
<h4 id="thread-control-block">Thread Control Block</h4>
<ul>
<li>thread ID</li>
<li>program counter</li>
<li>register set</li>
<li>stack</li>
</ul>
<h4 id="sequential-multi-threaded-program">Sequential/Multi-threaded program</h4>
<ul>
<li>Sequential program: program with only 1 stream of instruction</li>
<li>multi-threaded program: program with n streams of instruction</li>
</ul>
<h4 id="single-multi-threaded-processes">single/multi-threaded processes</h4>
<ul>
<li>single thread process: traditional process</li>
<li>multithreaded process: same code, data, file. but multiple threads. Perform more than 1 task at time</li>
</ul>
<h4 id="thread-life-cycle">Thread life cycle</h4>
<p>{{&lt; figure src=“/ox-hugo/threadlifecycle.png” &gt;}}</p>
<!--list-separator-->
<ul>
<li>Preemption</li>
</ul>
<h4 id="amdahl-s-law">Amdahl’s law</h4>
<p>\(speedup \) where S stands for <code>serial parts of the program</code> the law states:</p>
<ul>
<li>the speed up rise with N(core number) rise</li>
<li>the speed converge to \(\) as N approach \(\).</li>
</ul>
<h4 id="challenges-with-multicore-programming">Challenges with multicore programming</h4>
<ul>
<li>Identifying Tasks find areas that can be devided into concurrent threads They should be independent.</li>
<li>Balance some task are too small to run seperately. like x = x + 1.</li>
<li>Data splitting the data accessed should be devided to corresponding processors.</li>
<li>Data dependency when proc1 depend on the result of proc2. They should be synchronized, so that the data is used right.</li>
<li>Testing and debugging The possible order of instruction execution increase largely when concurent.</li>
</ul>
<h4 id="concurrency-parallelism">Concurrency/Parallelism</h4>
<ul>
<li>Concurrency: little bit of every one</li>
<li>parallelism: more cores.</li>
</ul>
<!--list-separator-->
<ul>
<li><p>types of parallelism</p>
<ul>
<li>data parallelism data is divided to cores for identical operation array1.sum() =&gt; array1[:5].sum() + array1[5:].sum()</li>
<li>Task parallelism unique operation to cores</li>
</ul></li>
</ul>
<h4 id="synchrounous-threading">Synchrounous threading</h4>
<!--list-separator-->
<ul>
<li><p>fork-join strategy</p>
<p>parent fork child, and wait for them all to terminate. data sharing is significant. The parent may use all the data child manipulated.</p></li>
</ul>
<h4 id="threading-support">Threading Support</h4>
<!--list-separator-->
<ul>
<li><p>User level libraries</p>
<p>library create and manages threads program -libs-&gt; multiple little threads scheduled -&gt; new program -&gt; load as process -&gt; single threaded process on 1 core.</p>
<p><!--list-separator--></p>
<ul>
<li><p>pro</p>
<ul>
<li>no mode switching -&gt; fast</li>
<li>options for scheduling</li>
<li>not OS specific</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>con</p>
<ul>
<li>the blocking system calls would block the whole process, and threfore all threads of the process</li>
<li>no parallelism</li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Kernel level</p>
<p>kernel create and manages, schedules threads.</p>
<p><!--list-separator--></p>
<ul>
<li><p>pro</p>
<ul>
<li>use multiple cores</li>
<li>blocking at thread level</li>
<li>multithread kernel routines(everybody multithread)</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>con</p>
<ul>
<li>thread switch always involves kernel -&gt; mode switch -&gt; slower</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lightweight-process">lightweight process</h4>
<p>an intermediate data structure between user and kernel threads</p>
<ul>
<li>to user: virtual processor</li>
<li>to kernel: attach to a kernel therads</li>
<li>when blocking happens: block on thread level, not process.</li>
<li>could use multiple cores.</li>
</ul>
<h4 id="multithreading-models">multithreading models</h4>
<!--list-separator-->
<ul>
<li><p>M to O</p>
<p>with Thread librarys. the functions in the library schedule the threads into 1 large thread, feeding to 1 kernel thread.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>O to M</p>
<p>each user thread map to one kernel thread. concurrency, clever blocking. the overhead could be troublesome, so often the number of threads are restricted</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>M to M</p>
<p>a set of threads map to a set of kernel therad with less or equal degree. Therefore unlimited user threads, concurrency and clever blocking.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>2 level</p>
<p>M to M + O to O side by side.</p></li>
</ul>
<h4 id="thread-libraries">Thread libraries</h4>
<p>lib that provide functions to <code>create</code> <code>use</code> <code>terminate</code> therads</p>
<!--list-separator-->
<ul>
<li><p>Thread API</p>
<p>Functions and Data structure of the thread library. like <code>future</code>, <code>thread</code>.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>POSIX</p>
<p><!--list-separator--></p>
<ul>
<li>Pthread</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li>Java</li>
</ul>
<!--list-separator-->
<ul>
<li>Win32</li>
</ul>
<!--list-separator-->
<ul>
<li><p>Implementation</p>
<ul>
<li>in user space: local function call codes and data structure in user space</li>
<li>kernel level: system call codes and data structure in kernel space</li>
</ul></li>
</ul>
<h4 id="asynchronous-synchronous-threading">Asynchronous/synchronous threading</h4>
<ul>
<li>Asynchronous: parent don’t wait child</li>
<li>synchronous: parent wait child.</li>
</ul>
<h4 id="explicit-inplicit-threading">Explicit/Inplicit threading</h4>
<!--list-separator-->
<ul>
<li><p>Explicit threading</p>
<p>Programmer create and manage the threads</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Inplicit threading</p>
<p>compilers and run-time libs create and manage threads</p>
<p><!--list-separator--></p>
<ul>
<li><p>Thread pool</p>
<p>a pool of threads init at process init. They sit and wait for work. when works come, 1 thread will be call from the pool, and return after the work done.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>OpenMP</p>
<p>set of compiler directives for C,C++,Fortran, that instruct compiler to generate parallel code automatically. <code>parallel region</code> is idendtified with the directives.</p>
<p><!--list-separator--></p>
<ul>
<li><p>parallel region</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]){</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel </span><span class="co">//the parallel region</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;I am a parallel region.&quot;</span>);</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Grand Central Dispatch</p>
<p>extension to C and C++ on macOS and iOS to support parallelism it use</p>
<p><!--list-separator--></p>
<ul>
<li><p>blocks</p>
<p><code>^{printf("hi");}</code></p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>dispatch queue</p>
<p>blocks as unit, go in that queue. when block removed, the block goes to a thread.</p>
<ul>
<li>queue types:
<ul>
<li>serial: FIFO, 1 by 1</li>
<li>concurrent: FIFO, n by n. there’s 3 concurrent queue with different priority.</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>main queue</p>
<p>every process have this serial queue</p></li>
</ul></li>
</ul></li>
</ul>
<h4 id="asynchronous-procedure-call--apc">asynchronous procedure call (APC)</h4>
<h4 id="fork">fork()</h4>
<p>create a new child thread from the parent thread. an identical copy.</p>
<!--list-separator-->
<ul>
<li>child/parent thread</li>
</ul>
<h4 id="exec">exec()</h4>
<p>replace the executable of the thread. others stay the same.</p>
<!--list-separator-->
<ul>
<li>interaction of exec() and fork()</li>
</ul>
<h4 id="signal-handling">signal handling</h4>
<p>a interrupt or event generated by a unix system in response to a condition/actoin</p>
<!--list-separator-->
<ul>
<li><p>signal handler</p>
<p>the function handling the signal all signals are handled exactly once</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>asynchronous signal</p>
<p>from outside the process that receives it</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>synchronous signal</p>
<p>from the same process</p></li>
</ul>
<h4 id="thread-cancellation">thread cancellation</h4>
<!--list-separator-->
<ul>
<li>target thread</li>
</ul>
<!--list-separator-->
<ul>
<li><p>Asynchronous cancellation</p>
<p>terminate the target thread immediately</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Deferred cancellation</p>
<p>the target thread periodically check if it should be terminated. the canceled thread has sent the cancellation request</p>
<p><!--list-separator--></p>
<ul>
<li>cancellation point</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>cleanup handler</li>
</ul></li>
</ul>
<h4 id="single-to-multi-thread">single- to multi-thread</h4>
<h4 id="thread-local-storage--tls">Thread-local storage (TLS)</h4>
<h4 id="scheduler-activations--lightweight-process">Scheduler Activations (lightweight process)</h4>
<!--list-separator-->
<ul>
<li>upcall</li>
</ul>
<!--list-separator-->
<ul>
<li>upcall handler</li>
</ul>
<h4 id="linux-thread-story">Linux thread story</h4>
<h3 id="process-synchronization">Process Synchronization</h3>
<h4 id="coordination-of-process">coordination of process</h4>
<p>manageing the execution of processes so that no 2 processes access same resource the same time</p>
<h4 id="share-resource">share resource</h4>
<h4 id="critical-section-problem">critical-section problem</h4>
<!--list-separator-->
<ul>
<li><p>critical section</p>
<p>the area where the shared data is accesed</p>
<p><img src="/ox-hugo/racecondition.png" /> to ensure the correctness, the logical parallelism is turned off in critical section.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>entry section</p>
<p>code entering critical section</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>exit section</p>
<p>code leaves critical section</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>remainder section</p>
<p>code other than the above 3 sections.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>solution</p>
<p><!--list-separator--></p>
<ul>
<li><p>requirement</p>
<p><!--list-separator--></p>
<ul>
<li><p>Mutal Exclusion</p>
<p>only 1 process is in critical section.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Progress</p>
<p>when 0 process is in critical section, someone could get into critical section. when 2 process competeing, 1 must win.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Bounded waiting.</p>
<p>the waiting time should be limited. 1 process would lose,lose,lose…win!</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>software</p>
<p>rely on algorithms ensuring only 1 process in critical section. since CS is untouchable, use entry and exit section to build the system.</p>
<p><!--list-separator--></p>
<ul>
<li><p>Peterson’s Solution</p>
<p>by Gary L. Peterson in 1981 between 2 process P0 and P1</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> turn; <span class="co">//whose turn it is to enter</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>boolean flag[<span class="dv">2</span>]; <span class="co">//init to FALSE. flag[i] = TRUE -&gt; Pi is ready.</span></span></code></pre></div>
<p><!--list-separator--></p>
<ul>
<li><p>Peterson’s Algorithm</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">//entry section start</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  flag[<span class="dv">0</span>] = true; <span class="co">//P0 ready</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  turn = <span class="dv">1</span>; <span class="co">//give away turn</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (flag[<span class="dv">1</span>]&amp;&amp;turn==<span class="dv">1</span>); <span class="co">//wait while P1 is ready and having its turn</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  critical_section();</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">//entry section end</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  flag[<span class="dv">0</span>] = false; <span class="co">//exit section</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">//remainder section.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a> } <span class="cf">while</span> (true);</span></code></pre></div></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>cons</p>
<ul>
<li>complicated to program</li>
<li>busy waiting(CPU wasted)</li>
<li>it’s better to just block the waiting process. but that involves OS</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>hardware</p>
<p>rely on machine instruction of <a href="#locks">Locks</a></p>
<p><!--list-separator--></p>
<ul>
<li><p>Locks</p>
<p>lock on the required resource at <a href="#entry-section">entry section</a> remove lock at <a href="#exit-section">exit section</a></p>
<p><!--list-separator--></p>
<ul>
<li>Test and Set solution</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>compare and swap</p>
<p>the Pi finds lock = 0 proceed. Pi lock other proc by setting lock = 1. at exit, Pi set lock = 0 to enable progress.</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>pro</p>
<ul>
<li>scalable. work on n proc. on n cores.</li>
<li>simple</li>
<li>multipel CS supported</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>con</p>
<p><!--list-separator--></p>
<ul>
<li>busy-waiting</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>starvation</p>
<p>infinite blocking 1 proc leave CS, multiple waiting.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>deadlock</p>
<p>iofinite waiting to a signal from the other. priority. High priority will obtain processor, while the current proc. don’t have one to exit CS</p></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>OS and PL solution</p>
<p>provide function/stucture to use for synchronization</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Mutex lock/Mutual Exclusion</p>
<p>apply lock at entry, remove lock at exit. block proc. asking for lock while the lock is unavailable</p>
<p><!--list-separator--></p>
<ul>
<li><p>kernel-level</p>
<p>disable interupts</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>software-level</p>
<p><!--list-separator--></p>
<ul>
<li><p>busy waiting(spinning)</p>
<p>constantly check if a lock is available.</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>spinlock</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Semaphores</p>
<p>Semaphore is a Integer var, that is only accessed by wait() and signal().</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>wait(){</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(signal&lt;=<span class="dv">0</span>);</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  signal--;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>siganl(){</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  signal++;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>by init signal to n, enable n processes into CS at same time.</p>
<p><!--list-separator--></p>
<ul>
<li><p>counting semaphore</p>
<p>semaphore goes to n for resource having multiple instances</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>binary semaphore</p>
<p>semaphore init to 1</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>issue with semaphore</li>
</ul></li>
</ul></li>
</ul>
<h4 id="atomic-instuction">atomic instuction</h4>
<p>instruction that is not interuptable.</p>
<h4 id="preemptive-nonpreemptive-kernel">Preemptive/nonpreemptive kernel</h4>
<h4 id="multiprogramming">multiprogramming</h4>
<h4 id="synchronization-hardware">Synchronization hardware</h4>
<h4 id="race-condition">Race condition</h4>
<p>the condition that multiple proc.s manipulate same shared data concurrently. final value depends on the random order of the manipulation.</p>
<p>To prevent race condition, concurrent processes must be synchronized</p>
<h4 id="classical-process-synchronization-probelms">classical process-synchronization probelms</h4>
<!--list-separator-->
<ul>
<li><p>The Bounded-Buffer / Producer-Consumer Problem</p>
<p>{{&lt; figure src=“/ox-hugo/boundedbuffer.png” &gt;}}</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>The Readers–Writers Problem</p>
<p>n readers, n writers. readers read, writers write. write: only 1 writer access the shared data. read: all reader and non writer can access the shared data use a reader-writer lock that specify the mode of lock.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>The Dining-Philosophers Problem</p>
<p>{{&lt; figure src=“/ox-hugo/diningphilosopher.png” &gt;}}</p>
<p><!--list-separator--></p>
<ul>
<li><p>solutions</p>
<ul>
<li>allow only 4 philosopher to be hungary together</li>
<li>allow pickup only if both chopsticks available(in CS)</li>
<li>odd # philosophers pick left chopstick 1st</li>
<li>Even # philosopher always picks up right chopstick 1st</li>
</ul></li>
</ul></li>
</ul>
<h4 id="monitor">Monitor</h4>
<h3 id="cpu-scheduling">CPU Scheduling</h3>
<h4 id="concepts">concepts</h4>
<!--list-separator-->
<ul>
<li><p>Execution phases of a process</p>
<p>interleaved with <code>cpu-burst</code> and <code>io-burst</code></p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>CPU-I/O Burst Cycle</p>
<p>each process is build up with interleaved cpu-burst and io-burst.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Type of I/O Processes</p>
<p>whether the process is I/O bound or CPU bound determined the apropriate scheduling algorithm</p>
<p><!--list-separator--></p>
<ul>
<li><p>I/O bound</p>
<p>many short cpu burst mostly waiting for I/O affect user interaction.(word processor/emacs)</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>CPU Bound</p>
<p>few long cpu burst I/O very few long cpu burst helps could do with lower priority(3d rendering, machine learning)</p></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Preemptive/non-preemptive Scheduling</p>
<ul>
<li>preemptive: the OS can stop execution of the running process on cpu</li>
<li>non-preemptive: the OS can’t stop the current process. Must wait until it exit.</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>CPU Schedulers</p>
<ul>
<li>Trigger:
<ul>
<li>timer interrupt</li>
<li>running process blocked by I/O</li>
<li>By means of state change:
<ul>
<li>Running to Ready [interrupt] <code>preemptive</code></li>
<li>Running to Waiting [I/O request/wait()] <code>non-preemptive</code></li>
<li>Waiting to Ready [I/O complete] <code>preemptive</code></li>
<li>* to Terminate <code>non-preemptive</code></li>
</ul></li>
</ul></li>
<li>deed:
<ol type="1">
<li>triggered</li>
<li>pick another process from ready queue</li>
<li>perform context switch</li>
</ol></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Dispatcher</p>
<p>hand in control of CPU to the selected process(by short-term scheduler) called in every process switch</p>
<ol type="1">
<li>switch context</li>
<li>switch to user-mode</li>
<li>jump to the execution location in the program</li>
</ol>
<p><!--list-separator--></p>
<ul>
<li><p>dispatch latency</p>
<p>time of dispatcher stop and start process.</p></li>
</ul></li>
</ul>
<h4 id="criteria">criteria</h4>
<ul>
<li>Max CPU utilization – keep the CPU as busy as possible</li>
<li>Max Throughput – complete as many processes as possible per unit time</li>
<li>Fairness - give each process a fair share of CPU</li>
<li>Min Waiting time – process should not wait long in the ready queue</li>
<li>Min Response time – CPU should respond immediately</li>
</ul>
<h4 id="algorithms">algorithms</h4>
<!--list-separator-->
<ul>
<li><p>Terms</p>
<p><!--list-separator--></p>
<ul>
<li><p>Arrive Time</p>
<p>point of process arrives in the <u>ready queue</u></p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Completion Time</p>
<p>point of process complete execution</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Burst time</p>
<p>duration required by a process for CPU execution</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Turnaround time</p>
<p>duration of | 1st time into ready state -…-&gt; complete | turnaround time = Completion time - Arrive time</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Waiting Time</p>
<p>duration of process waiting in ready queue Waiting Time = Turnaround Time - Burst Time</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Response Time</p>
<p>Point of process gets CPU for the 1st time</p></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Algors</p>
<p><!--list-separator--></p>
<ul>
<li><p>First-Come, First-Served (FCFS) Scheduling</p>
<ul>
<li>first-come, first-served</li>
<li>waiting time high</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Shortest-Job-First (SJF) Scheduling</p>
<p>without preemption aims at <code>shortest burst time</code></p>
<p><!--list-separator--></p>
<ul>
<li><p>estimate next burst time</p>
<p>e = estimated time t = actual time a = weight factor (1 &lt; a &lt; 0)</p>
<p>\(e_{n+1} = at_n +(1-a)e_{n}\)</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>pro</p>
<ul>
<li>min average waiting time</li>
<li>min average response time</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>con</p>
<ul>
<li>not practical: burst time unknown so SJF cannont be implemented at short term scheduling level</li>
<li>starve long job.</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Shortest Remaining Time First (SRTF) Scheduling</p>
<ul>
<li>When the new-comer have the shortest burst time, switch to him.</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Priority Scheduling</p>
<ul>
<li>Each process assigned a priority
<ul>
<li>based on:
<ul>
<li>OS criteria(memory…)</li>
<li>admin’s choice</li>
</ul></li>
</ul></li>
<li>cpu allocated to highest priority</li>
<li>Probelm:
<ul>
<li>Starvation: low priority never exec.
<ul>
<li>solution: aging.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Round Robin(RR) Scheduling</p>
<ul>
<li>a quantom of time <code>q</code> for everyone q of P1, then q of P2….</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Performance</p>
<ul>
<li>large q: FCFS</li>
<li>small q: cost of overhead. Large compared with context switch.</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multiple-Level Queues Scheduling</p>
<ul>
<li>Ready queue partitioned (permanantly) into 2 queues:
<ul>
<li>Foreground Proc</li>
<li>Background Proc</li>
</ul></li>
<li>Schedule in 2 types:
<ul>
<li>To the Queues</li>
<li>In the Queue</li>
</ul></li>
<li>Among the Queues:
<ul>
<li>Fixed Priority Scheduling first forground, then backgound</li>
<li>Time slice 80% time Forground in RR, 20% time Background in FCFS</li>
</ul></li>
<li>Categories of Proc: in them the priority desc
<ul>
<li>Interactive processes</li>
<li>Non-interactive processes</li>
<li>CPU-bound processes</li>
<li>I/O-bound processes</li>
<li>Background processes</li>
<li>Foreground processes</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multilevel Feedback Queue Scheduling</p>
<p>place process into priority queues based on their CPU burst behaviour</p>
<ul>
<li>IO higher, CPU lower</li>
<li>Basic Rules:
<ol type="1">
<li>New proc. highest priority</li>
<li>quantum finished: (if proc not finish) into next lower queuef</li>
</ol></li>
<li>Parameters
<ul>
<li>n queues</li>
<li>scheduling algorithem for each queue</li>
<li>upgrade method</li>
<li>demote method</li>
<li>queue select method</li>
</ul></li>
<li>Example
<ul>
<li>Q1: RR 8ms</li>
<li>Q2: RR 16ms</li>
<li>Q3: FCFS</li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Thread Scheduling</p>
<p><!--list-separator--></p>
<ul>
<li><p>contention scope</p>
<p>the scope where the user threads compete for use of physical CPU</p>
<p><!--list-separator--></p>
<ul>
<li><p>Process Contention Scope PCS (unbound thread)</p>
<p>local. many-to-one</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>System Contention Scope SCS (bound thread)</p>
<p>global one-to-one</p></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multiple-Processor Scheduling</p>
<p><!--list-separator--></p>
<ul>
<li><p>inside Multiprocessor OS</p>
<ul>
<li>Require different inter-proc. comminucation &amp; synchronization techniques</li>
<li>All processors share a memory</li>
<li></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>3 structures</p>
<p><!--list-separator--></p>
<ul>
<li><p>Separate Kernel Configuration</p>
<p>every Processor have it’s own I/O device and file system little interdependency</p>
<ul>
<li>no parrallel execution</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Master–Slave Configuration (Asymmetric Configuration)</p>
<p>1 master processor and other slave processors OS run by master process scheduling run by master</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Symmetric Configuration</p>
<p>Any processor can access any device and can handle any interrupts generated on it.</p>
<p>Mutual Exclusion for the OS is required. OS is seperated into independent parts. to prevent concurrency</p>
<p><!--list-separator--></p>
<ul>
<li><p>approaches</p>
<p><!--list-separator--></p>
<ul>
<li>common ready queue</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>per-core run queues</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Process Affinity</p>
<p>caches make 1 processor more “familier” for a process. So it’s better to use 1 processor all along.</p>
<p><!--list-separator--></p>
<ul>
<li><p>soft affinity</p>
<p>no guarentee</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>hard affinity</p>
<p>allowing a</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Load Balencing</p>
<p>for each core’s queue</p>
<p><!--list-separator--></p>
<ul>
<li><p>Push migration</p>
<p>when too long, push task to other processor’s queue</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Pull migration</p>
<p>when empty ready queue, read from othre processors’ queue. Transfer them into my own queue</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multicore Processors</p>
<p>a core executes a thread a time</p>
<p><!--list-separator--></p>
<ul>
<li><p>Memory stall</p>
<p>single-core processor waiting for the data to become available.</p>
<p>use that time to execute other thread.</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Hyperthreading</p>
<p>a intel technology a physical processor divieded into 2 logical processors that are treated like seperate physical processors.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multithreading</p>
<p>multiple thread on same core</p>
<p><!--list-separator--></p>
<ul>
<li><p>coarse-grained</p>
<p>switch thread only when 1 thread block</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>fine-grained</p>
<p>scheduling in Round Robin policy</p></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Real-Time CPU Scheduling</p>
<p><!--list-separator--></p>
<ul>
<li><p>Real-time system</p>
<p>a system where time play important role</p>
<p><!--list-separator--></p>
<ul>
<li><p>hard real-time system</p>
<p>must meet deadline</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>soft real-time system</p>
<p>desirable not not necesary</p>
<p><!--list-separator--></p>
<ul>
<li><p>aperiodic tasks</p>
<p>irregular arrival time</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>periodic tasks</p>
<p>once per period T</p></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Scheduling real-time tasks</p>
<p>{{&lt; figure src=“/ox-hugo/realtimelatency.png” &gt;}}</p>
<p><!--list-separator--></p>
<ul>
<li><p>interrupt latency</p>
<p>determine interrupt type switch context</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>dispatch latency</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Static Scheduling</p>
<p>schedule prepared before app startup</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Priority-based scheduling</p>
<p>priority assigned base on how quickly it must react</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Dynamic scheduling</p>
<p>schedule change over time.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>timing constraints</p>
<ul>
<li>period:</li>
<li>deadline:</li>
<li></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>scheduling criteria</p>
<ul>
<li>timing constraints met</li>
<li>cost of context switch, while preempting, must be reduced</li>
<li></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>preemptively/non-preemptively, staticly/dynamically</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Rate-Monotonic Scheduling</p>
<p>static priority-based preemptive scheduling algorithm</p>
<p>shortest period = highest priority</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Earlies-Deadline-First Scheduling</p>
<p>deadline - priority dynamically assign priority according to deadline</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Proportional Share Scheduling</p>
<p>T shares are allocated to all procs. in the system An app recive N shares. N &lt; T</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Process in here</p>
<p>periodic.</p>
<ul>
<li>once the process get CPU, it has:
<ul>
<li><p>fixed processing time \(t\)</p></li>
<li><p>deadline \(d\)</p></li>
<li><p>period \(p\)</p></li>
<li><p>\(0 t d p\)</p></li>
<li><p>rate \(\)</p></li>
<li><p>illustrate</p>
<p>{{&lt; figure src=“/ox-hugo/ptd.png” &gt;}}</p></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Algorithm Evaluation</p>
<p>❑</p>
<p><!--list-separator--></p>
<ul>
<li><p>Deterministic evaluation</p>
<ol type="1">
<li>define workload: avg waiting time?</li>
<li>test.</li>
</ol></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Queueing Models</p>
<p>we define queues for I/O and CPU, then queueing theory comes in handy</p>
<p><!--list-separator--></p>
<ul>
<li><p>little’s formula</p>
<p>\(n = W\) n:average queue length W:avg waiting time \(\):avg arrival rate if we know 2 of the parameters, we know the thirs</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Simulations</p>
<p>trace tapes to provide real machine process to simulate algorithms on.</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="deadlock">Deadlock</h3>
<h4 id="system-model">System Model</h4>
<ul>
<li>system have resources.</li>
<li>Resource have R types</li>
<li>Resource have W Instances</li>
<li>Process Use Resource with:
<ul>
<li>request</li>
<li>use</li>
<li>release</li>
</ul></li>
</ul>
<h4 id="deadlock-characterizaiton">Deadlock Characterizaiton</h4>
<p>deadlock arise if the four condition the same time</p>
<!--list-separator-->
<ul>
<li><p>Mutual exclusion</p>
<p>1 process at a time hold that resource</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Hold and wait</p>
<p>the process holding 1 resource wait for the other one</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>No preemption</p>
<p>resource released only voluntarily</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Circular wait</p>
<p>closed chain of process waiting for resource from the next one in chain</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Resource allocation Graph</p>
<p>{{&lt; figure src=“/ox-hugo/resourceallocationgraph.png” &gt;}}</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Basic Facts</p>
<ul>
<li>graph have no cycle = no deadclock</li>
<li>have cycle:
<ul>
<li>1 instance per resource type = deadclock</li>
<li>n instances per resource type: possibilities.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="methods-for-handling-deadlocks">Methods for handling Deadlocks</h4>
<!--list-separator-->
<ul>
<li><p>Deadlock Prevention</p>
<p>try to eliminate 1 of the 4 conditions</p>
<p><!--list-separator--></p>
<ul>
<li><p>Mutual exclusion</p>
<p>no</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Hold and wait</p>
<p>limit max resource hold to 1. -&gt; low resource use,</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>No preemption</p>
<ul>
<li>when holding 1 asking 1 denyed, release all.</li>
<li>or if the asked 1 is held by other, preempt him</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Circular wait</p>
<p>order the resource types. restrict request object to R3-5 after holding R3.</p></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Deadlock Avoidence</p>
<p>constrain request to prevent least 1 of the 4 conditions.</p>
<ul>
<li>don’t start dangerous proc.</li>
<li>don’t grant dangerous request.</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>safe state</p>
<p>at least 1 sequence of resource allocation that does not result in deadlock</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Max need</p>
<p>total amount of each resources</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>available resource</p>
<p>total amount of each unallocated resources</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>need</p>
<p>future request from P1 for R2</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>allocation</p>
<p>the R0 and R1 that P1 have been holding.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>single instance of Resource</p>
<p><!--list-separator--></p>
<ul>
<li><p>claim edge</p>
<p>Pi may request Rj. if check cycle, reject, otherwise claim -&gt; request</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Multiple Instances of REsources</p>
<p><!--list-separator--></p>
<ul>
<li><p><code>Banker's algorithm</code></p>
<p><!--list-separator--></p>
<ul>
<li><p>Data structures</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>n = number of process;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>m = number of resource type;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>avalable[m] containing instance numbers;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>Max[n,m]. Max[i,j]=k,then Pi may request at most k instances of Rj;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>Allocation[n,m];Pi have k of Rjs;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>Need[n,m];Pi still need k of Rjs. Need[i,j] = Max[i,j]-Allocaiton[i,j]</span></code></pre></div></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Safety Test algo</p>
<ol type="1">
<li><p>init</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Work[m] = available[m];</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Finish[n]= false;</span></code></pre></div></li>
<li><p>find <code>i</code> such that:</p>
<ul>
<li>Finish[i] = false</li>
<li>Need[i]&lt;=Work[i]</li>
<li>if no, goto step 4</li>
</ul></li>
<li><p>work = work + allocation; finish[i]= true;goto step 2</p></li>
<li><p>if finish[i] = true for all i, then safe state.</p></li>
</ol></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Resource request algo</p>
<p>pretend to do the request. check that map.</p></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Deadlock Detection</p>
<p><!--list-separator--></p>
<ul>
<li><p>Detection of single instance of resource</p>
<p><!--list-separator--></p>
<ul>
<li><p>wait-for graph</p>
<p>merge resource.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>detection</p>
<p>search for loop in wait-for graph. O(n2)</p></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Detection for multiple instances of resources</p>
<p>banker’s algorithm.</p>
<p><!--list-separator--></p>
<ul>
<li>available</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>allocation</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>request</li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Usage</p>
<p>when? if too late, the deadlock would grow large and hard to deal with</p></li>
</ul></li>
</ul>
<h4 id="recovery-from-deadlock">Recovery from deadlock</h4>
<!--list-separator-->
<ul>
<li><p>Process Termination / Abort Process</p>
<p>➢ Abort all deadlocked processes ➢ Abort one process at a time until the deadlock cycle is eliminated</p>
<ul>
<li>Order</li>
<li>Priority of the process
<ol type="1">
<li>How long process has computed, and how much longer to completion</li>
<li>Resources the process has used</li>
<li>Resource’s process needs to complete</li>
<li>How many processes will need to be terminated</li>
<li>Is process interactive or batch?</li>
</ol></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Resource Preemption</p>
<ol type="1">
<li>select victim</li>
<li>rollback</li>
<li>starvation make sure limited time 1 is a victim</li>
</ol></li>
</ul>
<h2 id="the-project">The Project</h2>
<h3 id="scheduler">Scheduler</h3>
<p>My goal is to:</p>
<ol type="1">
<li>Gain practical experiance of OS</li>
<li>Pass [CPT104 OS Concepts]({{&lt; relref “20220220183600-cpt104.md” &gt;}}) with High score</li>
</ol>
<p>In order to do that, not only I should complete all CPT104 Activities, but also dig in using</p>
<ul>
<li>MIT6.S081 I stored thing in my download drive <a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">official schedule</a> holds schedule information of the course.</li>
<li>the Dinosaur book it contains much practical problems.</li>
</ul>
<p>The MIT course is in video and practices, and the dinosour book is a book. I plan to use <a href="#page-reading-machine">page reading machine</a> on <a href="#the-dinosaur-book">the Dinosaur book</a> and <a href="#video-watching-machine">video watching machine</a> on the video materails of MIT.</p>
<p>I’ll be holding Notes in this page, which, will be transformed into blogs in the future on my website.</p>
<p>Keep that in mind, and knows that there’s an audiance. So make them comprehensible, and complete.</p>
<h3 id="page-reading-machine">page reading machine</h3>
<h4 id="principle">Principle</h4>
<!--list-separator-->
<ul>
<li><p>Distributed Exposure</p>
<p>Various exposure to the materials build familiarance, the key to memory and understanding/processing.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>Initiative</p>
<p>Taking Initiative counters dizziness and copying.</p></li>
</ul>
<h4 id="flow">Flow</h4>
<ol type="1">
<li>Go through the headings, mark seemed important keywords to headings</li>
<li>after the first skim, go to the notes and try to explain them. When failed, check the text.</li>
<li><code>[[]]</code> juicy jargons along the way</li>
<li>after current node done…</li>
<li>navigate to the first link(<code>C-c C-x C-p</code>)</li>
<li>Create and edit the node</li>
<li>Refile it to where it belong(<code>C-c m</code>)</li>
<li>Back to the point using <code>org-mark-ring-goto(C-c 5)</code></li>
<li>Go to next link(<code>C-c C-x C-n</code>)</li>
<li>Repeat step 4-7 until all links are pointing to somewhere.</li>
</ol>
<h3 id="video-watching-machine">video watching machine</h3>
<h4 id="constructing-video-watching-machine"><span class="org-todo todo TODO">TODO</span> Constructing video watching machine</h4>
<!--list-separator-->
<ul>
<li><p><span class="org-todo todo TODO">TODO</span> Do a class conventionally, record obstacles.</p>
<p>Goal - Problem record - Diagnose - Plan - Execution.</p>
<p><!--list-separator--></p>
<ul>
<li><p>conventianl watching</p>
<ol type="1">
<li>Watch video</li>
<li>(Pause video to)Take note of every section</li>
<li>Take note of every listed experiance</li>
<li>Take note of every code.</li>
<li>Try the code myself.</li>
</ol>
<p><!--list-separator--></p>
<ul>
<li><p>Note</p>
<p><!--list-separator--></p>
<ul>
<li><p>Page table</p>
<p>a.k.a, virtual memory.</p>
<p><!--list-separator--></p>
<ul>
<li><p>why use Page table? =&gt; Isolation.</p>
<p>To implement <code>isolation between programs</code> in a <code>whole bulk of physical memory space</code>.</p>
<p><a href="#address-space">Address space</a> is the idea of an ideal Isolated Senario.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Address Space</p>
<p>Give every process it’s own <code>Address space</code></p>
<p><code>illustrate of 3 process having there own address space</code></p>
<p>There are various approaches to implement Address space. <a href="#page-table">Page Table</a> is one approach.</p></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Pageing Hardware</p>
<p>The hardware structure that supports <a href="#page-table">Page Table</a>, mainly by processor, or MMU</p>
<p><!--list-separator--></p>
<ul>
<li><p>Page Table</p>
<p><code>Illustrate of paging</code></p>
<ul>
<li>VA: Virtual Address, PA: Physical Address
<ul>
<li>VA: location of the code from the process’s perspective</li>
<li>PA: location of the code from main memory’s perspective</li>
</ul></li>
<li>CPU holds:
<ul>
<li>satp register: PA, location of page table in main memory.</li>
<li>other: VA, location of data or code address.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><!--list-separator--></p>
<ul>
<li>xv6 vm code+layout</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="practice">Practice</h3>
<p>The MIT course provides extensive lab practices. The completion and logging would be stored in <a href="#mit-6-dot-s081-lab-logs">MIT 6.S081 Lab Logs</a></p>
<h2 id="mit-6-dot-s081-lab-logs">MIT 6.S081 Lab Logs</h2>
<h3 id="lab-1-unix-utils">Lab 1: Unix utils</h3>
<h4 id="reading-xv6-ch1"><span class="org-todo todo TODO">TODO</span> reading xv6 ch1</h4>
<h4 id="xv6-system-calls">xv6 system calls</h4>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>System call</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int fork()</td>
<td>Create a process, return child’s PID.</td>
</tr>
<tr class="even">
<td>int exit(int status)</td>
<td>Terminate the current process; status reported to wait(). No return.</td>
</tr>
<tr class="odd">
<td>int wait(int *status)</td>
<td>Wait for a child to exit; exit status in *status; returns child PID.</td>
</tr>
<tr class="even">
<td>int kill(int pid)</td>
<td>Terminate process PID. Returns 0, or -1 for error.</td>
</tr>
<tr class="odd">
<td>int getpid()</td>
<td>Return the current process’s PID.</td>
</tr>
<tr class="even">
<td>int sleep(int n)</td>
<td>Pause for n clock ticks.</td>
</tr>
<tr class="odd">
<td>int exec(char *file, char *argv[])</td>
<td>Load a file and execute it with arguments; only returns if error.</td>
</tr>
<tr class="even">
<td>char *sbrk(int n)</td>
<td>Grow process’s memory by n bytes. Returns start of new memory.</td>
</tr>
<tr class="odd">
<td>int open(char *file, int flags)</td>
<td>Open a file; flags indicate read/write; returns an fd (file descriptor).</td>
</tr>
<tr class="even">
<td>int write(int fd, char *buf, int n)</td>
<td>Write n bytes from buf to file descriptor fd; returns n.</td>
</tr>
<tr class="odd">
<td>int read(int fd, char *buf, int n)</td>
<td>Read n bytes into buf; returns number read; or 0 if end of file.</td>
</tr>
<tr class="even">
<td>int close(int fd)</td>
<td>Release open file fd.</td>
</tr>
<tr class="odd">
<td>int dup(int fd)</td>
<td>Return a new file descriptor referring to the same file as fd.</td>
</tr>
<tr class="even">
<td>int pipe(int p[])</td>
<td>Create a pipe, put read/write file descriptors in p[0] and p[1].</td>
</tr>
<tr class="odd">
<td>int chdir(char *dir)</td>
<td>Change the current directory.</td>
</tr>
<tr class="even">
<td>int mkdir(char *dir)</td>
<td>Create a new directory.</td>
</tr>
<tr class="odd">
<td>int mknod(char *file, int, int)</td>
<td>Create a device file.</td>
</tr>
<tr class="even">
<td>int fstat(int fd, struct stat *st)</td>
<td>Place info about an open file into *st.</td>
</tr>
</tbody>
</table>
<p>cci| int stat(char *file, struct stat *st) | Place info about a named file into *st. |</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>int link(char *file1, char *file2)</th>
<th>Create another name (file2) for the file file1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int unlink(char *file)</td>
<td>Remove a file.</td>
</tr>
</tbody>
</table>
<h4 id="fork">fork()</h4>
<p>create a child process</p>
<!--list-separator-->
<ul>
<li><p>positions</p>
<ul>
<li>memory: same content, different location</li>
<li>file descriptors: the same</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>behaviour</p>
<ul>
<li>a child process created, with identical everything of the parent process.</li>
<li>child process and parent process don’t share memory variables</li>
<li>[?] whereever the <code>fork()</code> call is at, the whole program is duplicated</li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>returns</p>
<ul>
<li>pid of the created child [in parent]</li>
<li>0 [in child]</li>
</ul>
<p><!--list-separator--></p>
<ul>
<li><p>Tree of child processes</p>
<ul>
<li>Since
<ul>
<li>in child processes, the value of the creating fork() is 0</li>
<li>memory is duplicated for every child.</li>
</ul></li>
<li>Therefore
<ul>
<li>on a leaf child if use <code>pid1=fork()</code> to store the pid, then all processes in the route from root to this child would have pid stored 0.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="wait">wait()</h4>
<p>wait() is companion of <a href="#fork">fork()</a>, parent block until childs finish.</p>
<h4 id="exit">exit()</h4>
<h4 id="file-descriptor">File Descriptor</h4>
<p>it’s an integer. like, 0 - standard in, 1 - standard out, 2 - standard error</p>
<h4 id="read">read()</h4>
<h4 id="write">write()</h4>
<h4 id="file-system">File system</h4>
<h4 id="pipe">Pipe</h4>
<ul>
<li>1 pipe for one way communication.</li>
<li>the file</li>
</ul>
<h4 id="lab1-dot-2-sleep">lab1.2: sleep()</h4>
<p>I see that you need 1 pipe for each direction of communication, 1 for P1 to P2, and 1 for P2 to P1 Otherwise, when P1 finished writing and start to read, it could read the data it just write into the pipe.</p>
<h4 id="lab1-dot-3-prime">lab1.3: prime()</h4>
<ul>
<li>I see that procedure doing it is not promising: no</li>
<li>I see that funciton layer_init don’t work well. it don’t tell whether the nums are prime.</li>
<li>It’s key where the child is inited in the recursive calls. it should be not in the while loop for while loop is giving it chance to</li>
</ul>
<!--listend-->
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;../kernel/types.h&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;user.h&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;../kernel/stat.h&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(){</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> p1[<span class="dv">2</span>];</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  pipe(p1);</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (fork() == <span class="dv">0</span>){</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>;i&lt;<span class="dv">32</span>;i++){</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      write(p1[<span class="dv">1</span>],&amp;i,<span class="dv">4</span>);</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      printf(<span class="st">&quot;inited %d</span><span class="sc">\n</span><span class="st">&quot;</span>,i);</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    exit(<span class="dv">0</span>);</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  }<span class="cf">else</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    child_process(p1);</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> child_process(<span class="dt">int</span> p[<span class="dv">2</span>]){</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> prime;</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> child_p[<span class="dv">2</span>];</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  pipe(child_p);</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>  close(p[<span class="dv">1</span>]);</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> len = read(p[<span class="dv">0</span>],&amp;prime,<span class="dv">4</span>);</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  printf(<span class="st">&quot;prime: %d</span><span class="sc">\n</span><span class="st">&quot;</span>,prime);</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (len==<span class="dv">0</span>){close(p[<span class="dv">0</span>]);exit(<span class="dv">0</span>);}</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (fork()==<span class="dv">0</span>){</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    close(p[<span class="dv">0</span>]);</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    child_process(child_p);</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> num;</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> len = read(p[<span class="dv">0</span>],&amp;num,<span class="dv">4</span>);</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (len==<span class="dv">0</span>){close(p[<span class="dv">0</span>]);close(child_p[<span class="dv">1</span>]);</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    wait(<span class="dv">0</span>);</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    exit(<span class="dv">0</span>);</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> ( num % prime!= <span class="dv">0</span>){</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    write(child_p[<span class="dv">1</span>],&amp;num,<span class="dv">4</span>);</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!--list-separator-->
<ul>
<li><p>good recursive concurrent process call sturcure</p>
<ol type="1">
<li>every child process have it’s own setup -&gt; child_process()</li>
<li>fork(), and on the child process, invoke child_process()</li>
</ol>
<p>Then, the structure would be a lovely:</p>
<p>{{&lt; figure src=“/ox-hugo/recurrent.png” width=“400px” &gt;}}</p></li>
</ul>
<h4 id="miscellaneous">miscellaneous</h4>
<!--list-separator-->
<ul>
<li><p>main(int argc, char* argv[])</p>
<ul>
<li>argc: count of args passed by command-line</li>
<li>argv: args. typically, for <code>echo hi!</code>, <code>argv[0] = "echo", argv[1] = "hi!"</code></li>
</ul></li>
</ul>
<!--list-separator-->
<ul>
<li><p>how to add program?</p>
<ol type="1">
<li>write source code</li>
<li>add path to <code>UPROC</code> variable in <code>riscv-2019fall/Makefile</code></li>
<li>recompile with <code>make qemu</code> and the program should be loaded to the shell</li>
</ol></li>
</ul>
<!--list-separator-->
<ul>
<li><p>in usys.S</p>
<p>what <code>li</code> means in <code>li a7, SYS_sleep</code>?</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>loading sleep</p>
<p>write the code into user/sleep.c, and the Make would take care of later things.</p></li>
</ul>
<!--list-separator-->
<ul>
<li><p>page fault!</p>
<pre class="example"><code>init: starting sh
$ sleep
sleep
wrong number of args!usertrap(): unexpected scause 0x000000000000000f (store/AMO page fault) pid=3
        sepc=0x00000000000000fe stval=0x0000000000003038</code></pre>
<div class="src-block-caption">
<span class="src-block-number">Code Snippet 3</span>: shell output
</div></li>
</ul>
<!--list-separator-->
<ul>
<li><p>how large is 1 byte?</p>
<p>a int? a char?</p></li>
</ul>
<h2 id="address-space">Address space</h2>

</body>
</html>
